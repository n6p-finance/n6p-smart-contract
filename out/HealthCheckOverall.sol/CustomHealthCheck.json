{"abi":[{"type":"function","name":"check","inputs":[{"name":"profit","type":"uint256","internalType":"uint256"},{"name":"loss","type":"uint256","internalType":"uint256"},{"name":"debtPayment","type":"uint256","internalType":"uint256"},{"name":"debtOutstanding","type":"uint256","internalType":"uint256"},{"name":"callerStrategy","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"check(uint256,uint256,uint256,uint256,address)":"e53ec13f"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtOutstanding\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"callerStrategy\",\"type\":\"address\"}],\"name\":\"check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/src/HealthCheckOverall.sol\":\"CustomHealthCheck\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[\":@openzeppelin/=lib/openzeppelin-contracts/\",\":ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/src/HealthCheckOverall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR AGPL-3.0\\npragma solidity >=0.8.15;\\npragma experimental ABIEncoderV2;\\n\\ninterface CustomHealthCheck {\\n    function check(\\n        uint256 profit,\\n        uint256 loss,\\n        uint256 debtPayment,\\n        uint256 debtOutstanding,\\n        address callerStrategy\\n    ) external view returns (bool);\\n}\\n\\n\\n// LEGACY INTERFACES PRE 0.3.2\\nstruct LegacyStrategyParams {\\n    uint256 performanceFee;\\n    uint256 activation;\\n    uint256 debtRatio;\\n    uint256 rateLimit;\\n    uint256 lastReport;\\n    uint256 totalDebt;\\n    uint256 totalGain;\\n    uint256 totalLoss;\\n}\\n\\nstruct Limits {\\n    uint256 profitLimitRatio;\\n    uint256 lossLimitRatio;\\n    bool exists;\\n}\\n\\ncontract CommonHealthCheck {\\n    // Default Settings for all strategies\\n    uint256 constant MAX_BPS = 10_000;\\n    uint256 public profitLimitRatio;\\n    uint256 public lossLimitRatio;\\n    mapping(address => Limits) public strategiesLimits;\\n\\n    address public governance;\\n    address public management;\\n\\n    mapping(address => address) public checks;\\n\\n    modifier onlyGovernance() {\\n        _onlyGovernance();\\n        _;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        _onlyAuthorized();\\n        _;\\n    }\\n\\n    function _onlyGovernance() internal view {\\n        require(msg.sender == governance, \\\"!authorized\\\");\\n    }\\n\\n    function _onlyAuthorized() internal view {\\n        require(msg.sender == governance || msg.sender == management, \\\"!authorized\\\");\\n    }\\n\\n    constructor() {\\n        governance = msg.sender;\\n        management = msg.sender;\\n        profitLimitRatio = 300;\\n        lossLimitRatio = 100;\\n    }\\n\\n    function setGovernance(address _governance) external onlyGovernance {\\n        require(_governance != address(0));\\n        governance = _governance;\\n    }\\n\\n    function setManagement(address _management) external onlyGovernance {\\n        require(_management != address(0));\\n        management = _management;\\n    }\\n\\n    function setProfitLimitRatio(uint256 _profitLimitRatio) external onlyAuthorized {\\n        require(_profitLimitRatio < MAX_BPS);\\n        profitLimitRatio = _profitLimitRatio;\\n    }\\n\\n    function setlossLimitRatio(uint256 _lossLimitRatio) external onlyAuthorized {\\n        require(_lossLimitRatio < MAX_BPS);\\n        lossLimitRatio = _lossLimitRatio;\\n    }\\n\\n    function setStrategyLimits(\\n        address _strategy,\\n        uint256 _profitLimitRatio,\\n        uint256 _lossLimitRatio\\n    ) external onlyAuthorized {\\n        require(_lossLimitRatio < MAX_BPS);\\n        require(_profitLimitRatio < MAX_BPS);\\n        strategiesLimits[_strategy] = Limits(_profitLimitRatio, _lossLimitRatio, true);\\n    }\\n\\n    function setCheck(address _strategy, address _check) external onlyAuthorized {\\n        checks[_strategy] = _check;\\n    }\\n\\n    function check(\\n        uint256 profit,\\n        uint256 loss,\\n        uint256 debtPayment,\\n        uint256 debtOutstanding,\\n        uint256 totalDebt\\n    ) external view returns (bool) {\\n        return _runChecks(profit, loss, debtPayment, debtOutstanding, totalDebt);\\n    }\\n\\n    function _runChecks(\\n        uint256 profit,\\n        uint256 loss,\\n        uint256 debtPayment,\\n        uint256 debtOutstanding,\\n        uint256 totalDebt\\n    ) internal view returns (bool) {\\n        address customCheck = checks[msg.sender];\\n\\n        if (customCheck == address(0)) {\\n            return _executeDefaultCheck(profit, loss, totalDebt);\\n        }\\n\\n        return CustomHealthCheck(customCheck).check(profit, loss, debtPayment, debtOutstanding, msg.sender);\\n    }\\n\\n    function _executeDefaultCheck(\\n        uint256 _profit,\\n        uint256 _loss,\\n        uint256 _totalDebt\\n    ) internal view returns (bool) {\\n        Limits memory limits = strategiesLimits[msg.sender];\\n        uint256 _profitLimitRatio;\\n        uint256 _lossLimitRatio;\\n        if (limits.exists) {\\n            _profitLimitRatio = limits.profitLimitRatio;\\n            _lossLimitRatio = limits.lossLimitRatio;\\n        } else {\\n            _profitLimitRatio = profitLimitRatio;\\n            _lossLimitRatio = lossLimitRatio;\\n        }\\n\\n        if (_profit > ((_totalDebt * _profitLimitRatio) / MAX_BPS)) {\\n            return false;\\n        }\\n        if (_loss > ((_totalDebt * _lossLimitRatio) / MAX_BPS)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x84ea3605bb0cf0aed6960ee0dbb47111dcd34d84abf19c8d488d9bafefcbc73a\",\"license\":\"MIT OR AGPL-3.0\"}},\"version\":1}","metadata":{"compiler":{"version":"0.8.30+commit.73712a01"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"uint256","name":"profit","type":"uint256"},{"internalType":"uint256","name":"loss","type":"uint256"},{"internalType":"uint256","name":"debtPayment","type":"uint256"},{"internalType":"uint256","name":"debtOutstanding","type":"uint256"},{"internalType":"address","name":"callerStrategy","type":"address"}],"stateMutability":"view","type":"function","name":"check","outputs":[{"internalType":"bool","name":"","type":"bool"}]}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/"],"optimizer":{"enabled":true,"runs":1},"metadata":{"useLiteralContent":true,"bytecodeHash":"ipfs"},"compilationTarget":{"contracts/src/HealthCheckOverall.sol":"CustomHealthCheck"},"evmVersion":"shanghai","libraries":{},"viaIR":true},"sources":{"contracts/src/HealthCheckOverall.sol":{"keccak256":"0x84ea3605bb0cf0aed6960ee0dbb47111dcd34d84abf19c8d488d9bafefcbc73a","urls":[],"content":"// SPDX-License-Identifier: MIT OR AGPL-3.0\npragma solidity >=0.8.15;\npragma experimental ABIEncoderV2;\n\ninterface CustomHealthCheck {\n    function check(\n        uint256 profit,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 debtOutstanding,\n        address callerStrategy\n    ) external view returns (bool);\n}\n\n\n// LEGACY INTERFACES PRE 0.3.2\nstruct LegacyStrategyParams {\n    uint256 performanceFee;\n    uint256 activation;\n    uint256 debtRatio;\n    uint256 rateLimit;\n    uint256 lastReport;\n    uint256 totalDebt;\n    uint256 totalGain;\n    uint256 totalLoss;\n}\n\nstruct Limits {\n    uint256 profitLimitRatio;\n    uint256 lossLimitRatio;\n    bool exists;\n}\n\ncontract CommonHealthCheck {\n    // Default Settings for all strategies\n    uint256 constant MAX_BPS = 10_000;\n    uint256 public profitLimitRatio;\n    uint256 public lossLimitRatio;\n    mapping(address => Limits) public strategiesLimits;\n\n    address public governance;\n    address public management;\n\n    mapping(address => address) public checks;\n\n    modifier onlyGovernance() {\n        _onlyGovernance();\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        _onlyAuthorized();\n        _;\n    }\n\n    function _onlyGovernance() internal view {\n        require(msg.sender == governance, \"!authorized\");\n    }\n\n    function _onlyAuthorized() internal view {\n        require(msg.sender == governance || msg.sender == management, \"!authorized\");\n    }\n\n    constructor() {\n        governance = msg.sender;\n        management = msg.sender;\n        profitLimitRatio = 300;\n        lossLimitRatio = 100;\n    }\n\n    function setGovernance(address _governance) external onlyGovernance {\n        require(_governance != address(0));\n        governance = _governance;\n    }\n\n    function setManagement(address _management) external onlyGovernance {\n        require(_management != address(0));\n        management = _management;\n    }\n\n    function setProfitLimitRatio(uint256 _profitLimitRatio) external onlyAuthorized {\n        require(_profitLimitRatio < MAX_BPS);\n        profitLimitRatio = _profitLimitRatio;\n    }\n\n    function setlossLimitRatio(uint256 _lossLimitRatio) external onlyAuthorized {\n        require(_lossLimitRatio < MAX_BPS);\n        lossLimitRatio = _lossLimitRatio;\n    }\n\n    function setStrategyLimits(\n        address _strategy,\n        uint256 _profitLimitRatio,\n        uint256 _lossLimitRatio\n    ) external onlyAuthorized {\n        require(_lossLimitRatio < MAX_BPS);\n        require(_profitLimitRatio < MAX_BPS);\n        strategiesLimits[_strategy] = Limits(_profitLimitRatio, _lossLimitRatio, true);\n    }\n\n    function setCheck(address _strategy, address _check) external onlyAuthorized {\n        checks[_strategy] = _check;\n    }\n\n    function check(\n        uint256 profit,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 debtOutstanding,\n        uint256 totalDebt\n    ) external view returns (bool) {\n        return _runChecks(profit, loss, debtPayment, debtOutstanding, totalDebt);\n    }\n\n    function _runChecks(\n        uint256 profit,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 debtOutstanding,\n        uint256 totalDebt\n    ) internal view returns (bool) {\n        address customCheck = checks[msg.sender];\n\n        if (customCheck == address(0)) {\n            return _executeDefaultCheck(profit, loss, totalDebt);\n        }\n\n        return CustomHealthCheck(customCheck).check(profit, loss, debtPayment, debtOutstanding, msg.sender);\n    }\n\n    function _executeDefaultCheck(\n        uint256 _profit,\n        uint256 _loss,\n        uint256 _totalDebt\n    ) internal view returns (bool) {\n        Limits memory limits = strategiesLimits[msg.sender];\n        uint256 _profitLimitRatio;\n        uint256 _lossLimitRatio;\n        if (limits.exists) {\n            _profitLimitRatio = limits.profitLimitRatio;\n            _lossLimitRatio = limits.lossLimitRatio;\n        } else {\n            _profitLimitRatio = profitLimitRatio;\n            _lossLimitRatio = lossLimitRatio;\n        }\n\n        if (_profit > ((_totalDebt * _profitLimitRatio) / MAX_BPS)) {\n            return false;\n        }\n        if (_loss > ((_totalDebt * _lossLimitRatio) / MAX_BPS)) {\n            return false;\n        }\n        return true;\n    }\n}\n","license":"MIT OR AGPL-3.0"}},"version":1},"id":2}