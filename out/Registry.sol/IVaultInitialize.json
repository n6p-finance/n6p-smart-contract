{"abi":[{"type":"function","name":"initialize","inputs":[{"name":"token","type":"address","internalType":"address"},{"name":"governance","type":"address","internalType":"address"},{"name":"rewards","type":"address","internalType":"address"},{"name":"name","type":"string","internalType":"string"},{"name":"symbol","type":"string","internalType":"string"},{"name":"guardian","type":"address","internalType":"address"},{"name":"management","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"initialize(address,address,address,string,string,address,address)":"538baeab"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"management\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/src/core/Registry.sol\":\"IVaultInitialize\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[\":@openzeppelin/=lib/openzeppelin-contracts/\",\":ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/src/core/Registry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\ninterface IVaultRegistryView {\\n    function token() external view returns (address);\\n    function apiVersion() external view returns (string memory);\\n    function governance() external view returns (address);\\n}\\n\\ninterface IVaultInitialize {\\n    // Initialization (replaces Vyper initialize external)\\n    function initialize(\\n        address token,\\n        address governance,\\n        address rewards,\\n        string calldata name,\\n        string calldata symbol,\\n        address guardian,\\n        address management\\n    ) external;\\n}\\n\\ncontract Registry {\\n    // releases\\n    uint256 public numReleases;\\n    mapping(uint256 => address) public releases;\\n\\n    // token => vaults count\\n    mapping(address => uint256) public numVaults;\\n    mapping(address => mapping(uint256 => address)) public vaults; // token => id => vault\\n\\n    // tokens index\\n    mapping(uint256 => address) public tokens; // index => token\\n    uint256 public numTokens;\\n    mapping(address => bool) public isRegistered; // token => included\\n\\n    // governance (2-step)\\n    address public governance;\\n    address public pendingGovernance;\\n\\n    // tagging\\n    mapping(address => string) public tags; // vault => tag\\n    mapping(address => bool) public banksy; // tagger => allowed\\n\\n    event NewRelease(uint256 indexed release_id, address template, string api_version);\\n    event NewVault(address indexed token, uint256 indexed vault_id, address vault, string api_version);\\n    event NewExperimentalVault(address indexed token, address indexed deployer, address vault, string api_version);\\n    event NewGovernance(address governance);\\n    event VaultTagged(address vault, string tag);\\n\\n    constructor() {\\n        governance = msg.sender;\\n    }\\n\\n    // Governance\\n    function setGovernance(address _gov) external {\\n        require(msg.sender == governance, \\\"unauthorized\\\");\\n        pendingGovernance = _gov;\\n    }\\n    function acceptGovernance() external {\\n        require(msg.sender == pendingGovernance, \\\"unauthorized\\\");\\n        governance = msg.sender;\\n        emit NewGovernance(msg.sender);\\n    }\\n\\n    // Views\\n    function latestRelease() external view returns (string memory) {\\n        require(numReleases > 0, \\\"no release\\\");\\n        return IVaultRegistryView(releases[numReleases - 1]).apiVersion();\\n    }\\n    function latestVault(address token) external view returns (address) {\\n        require(numVaults[token] > 0, \\\"no vault for token\\\");\\n        return vaults[token][numVaults[token] - 1];\\n    }\\n\\n    // Release management vault version\\n    function newRelease(address vault) external {\\n        require(msg.sender == governance, \\\"unauthorized\\\");\\n        uint256 release_id = numReleases;\\n        if (release_id > 0) {\\n            string memory prev = IVaultRegistryView(releases[release_id - 1]).apiVersion();\\n            string memory next = IVaultRegistryView(vault).apiVersion();\\n            require(keccak256(bytes(prev)) != keccak256(bytes(next)), \\\"same api version\\\");\\n        }\\n        releases[release_id] = vault;\\n        numReleases = release_id + 1;\\n        emit NewRelease(release_id, vault, IVaultRegistryView(vault).apiVersion());\\n    }\\n\\n    // EIP-1167 minimal proxy clone using OpenZeppelin implementation\\n    function _clone(address implementation) internal returns (address instance) {\\n        return Clones.clone(implementation);\\n    }\\n\\n    function _newProxyVault(\\n        address token,\\n        address _governance,\\n        address rewards,\\n        address guardian,\\n        string memory name,\\n        string memory symbol,\\n        uint256 releaseTarget\\n    ) internal returns (address) {\\n        address release = releases[releaseTarget];\\n        require(release != address(0), \\\"unknown release\\\");\\n        address vault = _clone(release);\\n        // Match Vyper default for management (msg.sender), which would be Registry in that context\\n        IVaultInitialize(vault).initialize(token, _governance, rewards, name, symbol, guardian, address(this));\\n        return vault;\\n    }\\n\\n    function _registerVault(address token, address vault) internal {\\n        uint256 vault_id = numVaults[token];\\n        if (vault_id > 0) {\\n            string memory prev = IVaultRegistryView(vaults[token][vault_id - 1]).apiVersion();\\n            string memory next = IVaultRegistryView(vault).apiVersion();\\n            require(keccak256(bytes(prev)) != keccak256(bytes(next)), \\\"same api version\\\");\\n        }\\n        vaults[token][vault_id] = vault;\\n        numVaults[token] = vault_id + 1;\\n        if (!isRegistered[token]) {\\n            isRegistered[token] = true;\\n            tokens[numTokens] = token;\\n            numTokens += 1;\\n        }\\n        emit NewVault(token, vault_id, vault, IVaultRegistryView(vault).apiVersion());\\n    }\\n\\n    function newVault(\\n        address token,\\n        address guardian,\\n        address rewards,\\n        string calldata name,\\n        string calldata symbol,\\n        uint256 releaseDelta\\n    ) external returns (address) {\\n        require(msg.sender == governance, \\\"unauthorized\\\");\\n        uint256 releaseTarget = numReleases - 1 - releaseDelta; // underflow if none\\n        address vault = _newProxyVault(token, msg.sender, rewards, guardian, name, symbol, releaseTarget);\\n        _registerVault(token, vault);\\n        return vault;\\n    }\\n\\n    function newExperimentalVault(\\n        address token,\\n        address _governance,\\n        address guardian,\\n        address rewards,\\n        string calldata name,\\n        string calldata symbol,\\n        uint256 releaseDelta\\n    ) external returns (address) {\\n        uint256 releaseTarget = numReleases - 1 - releaseDelta; // underflow if none\\n        address vault = _newProxyVault(token, _governance, rewards, guardian, name, symbol, releaseTarget);\\n        emit NewExperimentalVault(token, msg.sender, vault, IVaultRegistryView(vault).apiVersion());\\n        return vault;\\n    }\\n\\n    function endorseVault(address vault, uint256 releaseDelta) external {\\n        require(msg.sender == governance, \\\"unauthorized\\\");\\n        require(IVaultRegistryView(vault).governance() == msg.sender, \\\"not governed\\\");\\n        uint256 releaseTarget = numReleases - 1 - releaseDelta; // underflow if none\\n        string memory api = IVaultRegistryView(releases[releaseTarget]).apiVersion();\\n        require(keccak256(bytes(IVaultRegistryView(vault).apiVersion())) == keccak256(bytes(api)), \\\"not target release\\\");\\n        _registerVault(IVaultRegistryView(vault).token(), vault);\\n    }\\n\\n    function setBanksy(address tagger, bool allowed) external {\\n        require(msg.sender == governance, \\\"unauthorized\\\");\\n        banksy[tagger] = allowed;\\n    }\\n\\n    function tagVault(address vault, string calldata tag) external {\\n        if (msg.sender != governance) {\\n            require(banksy[msg.sender], \\\"not banksy\\\");\\n        }\\n        tags[vault] = tag;\\n        emit VaultTagged(vault, tag);\\n    }\\n}\\n\\n\\n\",\"keccak256\":\"0x8fbbfe415e48db5e2e668fa7100ab846e46daca0a04c883bb5978eda8f4916de\",\"license\":\"MIT OR AGPL-3.0\"},\"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x01f055f5c26ba25d7f83e9aa9ba877fbea4d0bf22227de046ea67494bc932999\",\"license\":\"MIT\"}},\"version\":1}","metadata":{"compiler":{"version":"0.8.30+commit.73712a01"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"governance","type":"address"},{"internalType":"address","name":"rewards","type":"address"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"guardian","type":"address"},{"internalType":"address","name":"management","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"initialize"}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/"],"optimizer":{"enabled":true,"runs":1},"metadata":{"useLiteralContent":true,"bytecodeHash":"ipfs"},"compilationTarget":{"contracts/src/core/Registry.sol":"IVaultInitialize"},"evmVersion":"shanghai","libraries":{},"viaIR":true},"sources":{"contracts/src/core/Registry.sol":{"keccak256":"0x8fbbfe415e48db5e2e668fa7100ab846e46daca0a04c883bb5978eda8f4916de","urls":[],"content":"// SPDX-License-Identifier: MIT OR AGPL-3.0\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ninterface IVaultRegistryView {\n    function token() external view returns (address);\n    function apiVersion() external view returns (string memory);\n    function governance() external view returns (address);\n}\n\ninterface IVaultInitialize {\n    // Initialization (replaces Vyper initialize external)\n    function initialize(\n        address token,\n        address governance,\n        address rewards,\n        string calldata name,\n        string calldata symbol,\n        address guardian,\n        address management\n    ) external;\n}\n\ncontract Registry {\n    // releases\n    uint256 public numReleases;\n    mapping(uint256 => address) public releases;\n\n    // token => vaults count\n    mapping(address => uint256) public numVaults;\n    mapping(address => mapping(uint256 => address)) public vaults; // token => id => vault\n\n    // tokens index\n    mapping(uint256 => address) public tokens; // index => token\n    uint256 public numTokens;\n    mapping(address => bool) public isRegistered; // token => included\n\n    // governance (2-step)\n    address public governance;\n    address public pendingGovernance;\n\n    // tagging\n    mapping(address => string) public tags; // vault => tag\n    mapping(address => bool) public banksy; // tagger => allowed\n\n    event NewRelease(uint256 indexed release_id, address template, string api_version);\n    event NewVault(address indexed token, uint256 indexed vault_id, address vault, string api_version);\n    event NewExperimentalVault(address indexed token, address indexed deployer, address vault, string api_version);\n    event NewGovernance(address governance);\n    event VaultTagged(address vault, string tag);\n\n    constructor() {\n        governance = msg.sender;\n    }\n\n    // Governance\n    function setGovernance(address _gov) external {\n        require(msg.sender == governance, \"unauthorized\");\n        pendingGovernance = _gov;\n    }\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"unauthorized\");\n        governance = msg.sender;\n        emit NewGovernance(msg.sender);\n    }\n\n    // Views\n    function latestRelease() external view returns (string memory) {\n        require(numReleases > 0, \"no release\");\n        return IVaultRegistryView(releases[numReleases - 1]).apiVersion();\n    }\n    function latestVault(address token) external view returns (address) {\n        require(numVaults[token] > 0, \"no vault for token\");\n        return vaults[token][numVaults[token] - 1];\n    }\n\n    // Release management vault version\n    function newRelease(address vault) external {\n        require(msg.sender == governance, \"unauthorized\");\n        uint256 release_id = numReleases;\n        if (release_id > 0) {\n            string memory prev = IVaultRegistryView(releases[release_id - 1]).apiVersion();\n            string memory next = IVaultRegistryView(vault).apiVersion();\n            require(keccak256(bytes(prev)) != keccak256(bytes(next)), \"same api version\");\n        }\n        releases[release_id] = vault;\n        numReleases = release_id + 1;\n        emit NewRelease(release_id, vault, IVaultRegistryView(vault).apiVersion());\n    }\n\n    // EIP-1167 minimal proxy clone using OpenZeppelin implementation\n    function _clone(address implementation) internal returns (address instance) {\n        return Clones.clone(implementation);\n    }\n\n    function _newProxyVault(\n        address token,\n        address _governance,\n        address rewards,\n        address guardian,\n        string memory name,\n        string memory symbol,\n        uint256 releaseTarget\n    ) internal returns (address) {\n        address release = releases[releaseTarget];\n        require(release != address(0), \"unknown release\");\n        address vault = _clone(release);\n        // Match Vyper default for management (msg.sender), which would be Registry in that context\n        IVaultInitialize(vault).initialize(token, _governance, rewards, name, symbol, guardian, address(this));\n        return vault;\n    }\n\n    function _registerVault(address token, address vault) internal {\n        uint256 vault_id = numVaults[token];\n        if (vault_id > 0) {\n            string memory prev = IVaultRegistryView(vaults[token][vault_id - 1]).apiVersion();\n            string memory next = IVaultRegistryView(vault).apiVersion();\n            require(keccak256(bytes(prev)) != keccak256(bytes(next)), \"same api version\");\n        }\n        vaults[token][vault_id] = vault;\n        numVaults[token] = vault_id + 1;\n        if (!isRegistered[token]) {\n            isRegistered[token] = true;\n            tokens[numTokens] = token;\n            numTokens += 1;\n        }\n        emit NewVault(token, vault_id, vault, IVaultRegistryView(vault).apiVersion());\n    }\n\n    function newVault(\n        address token,\n        address guardian,\n        address rewards,\n        string calldata name,\n        string calldata symbol,\n        uint256 releaseDelta\n    ) external returns (address) {\n        require(msg.sender == governance, \"unauthorized\");\n        uint256 releaseTarget = numReleases - 1 - releaseDelta; // underflow if none\n        address vault = _newProxyVault(token, msg.sender, rewards, guardian, name, symbol, releaseTarget);\n        _registerVault(token, vault);\n        return vault;\n    }\n\n    function newExperimentalVault(\n        address token,\n        address _governance,\n        address guardian,\n        address rewards,\n        string calldata name,\n        string calldata symbol,\n        uint256 releaseDelta\n    ) external returns (address) {\n        uint256 releaseTarget = numReleases - 1 - releaseDelta; // underflow if none\n        address vault = _newProxyVault(token, _governance, rewards, guardian, name, symbol, releaseTarget);\n        emit NewExperimentalVault(token, msg.sender, vault, IVaultRegistryView(vault).apiVersion());\n        return vault;\n    }\n\n    function endorseVault(address vault, uint256 releaseDelta) external {\n        require(msg.sender == governance, \"unauthorized\");\n        require(IVaultRegistryView(vault).governance() == msg.sender, \"not governed\");\n        uint256 releaseTarget = numReleases - 1 - releaseDelta; // underflow if none\n        string memory api = IVaultRegistryView(releases[releaseTarget]).apiVersion();\n        require(keccak256(bytes(IVaultRegistryView(vault).apiVersion())) == keccak256(bytes(api)), \"not target release\");\n        _registerVault(IVaultRegistryView(vault).token(), vault);\n    }\n\n    function setBanksy(address tagger, bool allowed) external {\n        require(msg.sender == governance, \"unauthorized\");\n        banksy[tagger] = allowed;\n    }\n\n    function tagVault(address vault, string calldata tag) external {\n        if (msg.sender != governance) {\n            require(banksy[msg.sender], \"not banksy\");\n        }\n        tags[vault] = tag;\n        emit VaultTagged(vault, tag);\n    }\n}\n\n\n","license":"MIT OR AGPL-3.0"},"lib/openzeppelin-contracts/contracts/proxy/Clones.sol":{"keccak256":"0x01f055f5c26ba25d7f83e9aa9ba877fbea4d0bf22227de046ea67494bc932999","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n","license":"MIT"}},"version":1},"id":10}