{"abi":[{"type":"function","name":"basefee_global","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"basefee_global()":"9436dce4"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"basefee_global\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/src/CommonFeeOracle.sol\":\"IBaseFee\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[\":@openzeppelin/=lib/openzeppelin-contracts/\",\":ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/src/CommonFeeOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR AGPL-3.0\\npragma solidity ^0.8.20;\\n\\ninterface IBaseFee {\\n    function basefee_global() external view returns (uint256);\\n}\\n\\n/**\\n * @dev Interprets the base fee from our base fee provider\\n *  contract to determine if a harvest is permissable.\\n *\\n * Version 0.1.0\\n */\\n\\ncontract BaseFeeOracle {\\n    address public baseFeeProvider; /// @notice Provider to read current block's base fee. This will vary based on network.\\n    uint256 public maxAcceptableBaseFee; /// @notice Max acceptable base fee for the operation\\n\\n    address public governance; /// @notice Governance can grant and revoke access to the setter\\n    address public pendingGovernance; /// @notice New address must be set by current gov and then accept to transfer power.\\n    mapping(address => bool) public authorizedAddresses; /// @notice Addresses that can set the max acceptable base fee\\n\\n    bool public manualBaseFeeBool; /// @notice Use this if our network hasn't implemented the base fee method yet\\n\\n    constructor() {\\n        governance = msg.sender; // our deployer should be gov, they can set up the rest\\n        manualBaseFeeBool = true; // start as permissive\\n    }\\n\\n    // events for subgraph\\n    event NewGovernance(address indexed governance);\\n\\n    event NewProvider(address indexed provider);\\n\\n    event UpdatedMaxBaseFee(uint256 baseFee);\\n\\n    event UpdatedManualBaseFee(bool manualFee);\\n\\n    event UpdatedAuthorization(address indexed target, bool authorized);\\n\\n    /// @notice Returns whether we should allow harvests based on current base fee.\\n    function isCurrentBaseFeeAcceptable() public view returns (bool) {\\n        if (baseFeeProvider == address(0)) {\\n            return manualBaseFeeBool;\\n        } else {\\n            uint256 baseFee = IBaseFee(baseFeeProvider).basefee_global();\\n            return baseFee <= maxAcceptableBaseFee;\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the maximum base fee we want for our keepers to accept.\\n     *  Gwei is 1e9.\\n     * @dev Throws if the caller is not authorized or gov.\\n     * @param _maxAcceptableBaseFee The acceptable maximum price to pay in wei.\\n     */\\n    function setMaxAcceptableBaseFee(uint256 _maxAcceptableBaseFee) external {\\n        _onlyAuthorized();\\n        maxAcceptableBaseFee = _maxAcceptableBaseFee;\\n        emit UpdatedMaxBaseFee(_maxAcceptableBaseFee);\\n    }\\n\\n    /**\\n     * @notice If we don't have a provider, then manually determine if true or not.\\n     *  Useful in testing as well.\\n     * @dev Throws if the caller is not authorized or gov.\\n     * @param _manualBaseFeeBool Boolean to allow/block harvests if we don't\\n     *  have a provider set up.\\n     */\\n    function setManualBaseFeeBool(bool _manualBaseFeeBool) external {\\n        _onlyAuthorized();\\n        manualBaseFeeBool = _manualBaseFeeBool;\\n        emit UpdatedManualBaseFee(_manualBaseFeeBool);\\n    }\\n\\n    /**\\n     * @notice Controls whether a non-gov address can adjust certain params.\\n     * @dev Throws if the caller is not current governance.\\n     * @param _target The address to add/remove authorization for.\\n     * @param _value Boolean to grant or revoke access.\\n     */\\n    function setAuthorized(address _target, bool _value) external {\\n        _onlyGovernance();\\n        authorizedAddresses[_target] = _value;\\n        emit UpdatedAuthorization(_target, _value);\\n    }\\n\\n    /**\\n     * @notice Starts the 1st phase of the governance transfer.\\n     * @dev Throws if the caller is not current governance.\\n     * @param _governance The next governance address\\n     */\\n    function setPendingGovernance(address _governance) external {\\n        _onlyGovernance();\\n        pendingGovernance = _governance;\\n    }\\n\\n    /**\\n     * @notice Completes the 2nd phase of the governance transfer.\\n     * @dev Throws if the caller is not the pending caller.\\n     *  Emits a `NewGovernance` event.\\n     */\\n    function acceptGovernance() external {\\n        require(msg.sender == pendingGovernance, \\\"!authorized\\\");\\n        governance = msg.sender;\\n        emit NewGovernance(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Sets the address used to pull the current network base fee.\\n     * @dev Throws if the caller is not current governance.\\n     * @param _baseFeeProvider The network's baseFeeProvider address\\n     */\\n    function setBaseFeeProvider(address _baseFeeProvider) external {\\n        _onlyGovernance();\\n        baseFeeProvider = _baseFeeProvider;\\n        emit NewProvider(_baseFeeProvider);\\n    }\\n\\n    function _onlyAuthorized() internal view {\\n        require(authorizedAddresses[msg.sender] == true || msg.sender == governance, \\\"!authorized\\\");\\n    }\\n\\n    function _onlyGovernance() internal view {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x768fe9f7dc8f525022128a48c663c6ad6742be2a77c3f745525d42b49cc19592\",\"license\":\"MIT OR AGPL-3.0\"}},\"version\":1}","metadata":{"compiler":{"version":"0.8.20+commit.a1b79de6"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"view","type":"function","name":"basefee_global","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/"],"optimizer":{"enabled":true,"runs":1},"metadata":{"useLiteralContent":true,"bytecodeHash":"ipfs"},"compilationTarget":{"contracts/src/CommonFeeOracle.sol":"IBaseFee"},"evmVersion":"shanghai","libraries":{},"viaIR":true},"sources":{"contracts/src/CommonFeeOracle.sol":{"keccak256":"0x768fe9f7dc8f525022128a48c663c6ad6742be2a77c3f745525d42b49cc19592","urls":[],"content":"// SPDX-License-Identifier: MIT OR AGPL-3.0\npragma solidity ^0.8.20;\n\ninterface IBaseFee {\n    function basefee_global() external view returns (uint256);\n}\n\n/**\n * @dev Interprets the base fee from our base fee provider\n *  contract to determine if a harvest is permissable.\n *\n * Version 0.1.0\n */\n\ncontract BaseFeeOracle {\n    address public baseFeeProvider; /// @notice Provider to read current block's base fee. This will vary based on network.\n    uint256 public maxAcceptableBaseFee; /// @notice Max acceptable base fee for the operation\n\n    address public governance; /// @notice Governance can grant and revoke access to the setter\n    address public pendingGovernance; /// @notice New address must be set by current gov and then accept to transfer power.\n    mapping(address => bool) public authorizedAddresses; /// @notice Addresses that can set the max acceptable base fee\n\n    bool public manualBaseFeeBool; /// @notice Use this if our network hasn't implemented the base fee method yet\n\n    constructor() {\n        governance = msg.sender; // our deployer should be gov, they can set up the rest\n        manualBaseFeeBool = true; // start as permissive\n    }\n\n    // events for subgraph\n    event NewGovernance(address indexed governance);\n\n    event NewProvider(address indexed provider);\n\n    event UpdatedMaxBaseFee(uint256 baseFee);\n\n    event UpdatedManualBaseFee(bool manualFee);\n\n    event UpdatedAuthorization(address indexed target, bool authorized);\n\n    /// @notice Returns whether we should allow harvests based on current base fee.\n    function isCurrentBaseFeeAcceptable() public view returns (bool) {\n        if (baseFeeProvider == address(0)) {\n            return manualBaseFeeBool;\n        } else {\n            uint256 baseFee = IBaseFee(baseFeeProvider).basefee_global();\n            return baseFee <= maxAcceptableBaseFee;\n        }\n    }\n\n    /**\n     * @notice Set the maximum base fee we want for our keepers to accept.\n     *  Gwei is 1e9.\n     * @dev Throws if the caller is not authorized or gov.\n     * @param _maxAcceptableBaseFee The acceptable maximum price to pay in wei.\n     */\n    function setMaxAcceptableBaseFee(uint256 _maxAcceptableBaseFee) external {\n        _onlyAuthorized();\n        maxAcceptableBaseFee = _maxAcceptableBaseFee;\n        emit UpdatedMaxBaseFee(_maxAcceptableBaseFee);\n    }\n\n    /**\n     * @notice If we don't have a provider, then manually determine if true or not.\n     *  Useful in testing as well.\n     * @dev Throws if the caller is not authorized or gov.\n     * @param _manualBaseFeeBool Boolean to allow/block harvests if we don't\n     *  have a provider set up.\n     */\n    function setManualBaseFeeBool(bool _manualBaseFeeBool) external {\n        _onlyAuthorized();\n        manualBaseFeeBool = _manualBaseFeeBool;\n        emit UpdatedManualBaseFee(_manualBaseFeeBool);\n    }\n\n    /**\n     * @notice Controls whether a non-gov address can adjust certain params.\n     * @dev Throws if the caller is not current governance.\n     * @param _target The address to add/remove authorization for.\n     * @param _value Boolean to grant or revoke access.\n     */\n    function setAuthorized(address _target, bool _value) external {\n        _onlyGovernance();\n        authorizedAddresses[_target] = _value;\n        emit UpdatedAuthorization(_target, _value);\n    }\n\n    /**\n     * @notice Starts the 1st phase of the governance transfer.\n     * @dev Throws if the caller is not current governance.\n     * @param _governance The next governance address\n     */\n    function setPendingGovernance(address _governance) external {\n        _onlyGovernance();\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Completes the 2nd phase of the governance transfer.\n     * @dev Throws if the caller is not the pending caller.\n     *  Emits a `NewGovernance` event.\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"!authorized\");\n        governance = msg.sender;\n        emit NewGovernance(msg.sender);\n    }\n\n    /**\n     * @notice Sets the address used to pull the current network base fee.\n     * @dev Throws if the caller is not current governance.\n     * @param _baseFeeProvider The network's baseFeeProvider address\n     */\n    function setBaseFeeProvider(address _baseFeeProvider) external {\n        _onlyGovernance();\n        baseFeeProvider = _baseFeeProvider;\n        emit NewProvider(_baseFeeProvider);\n    }\n\n    function _onlyAuthorized() internal view {\n        require(authorizedAddresses[msg.sender] == true || msg.sender == governance, \"!authorized\");\n    }\n\n    function _onlyGovernance() internal view {\n        require(msg.sender == governance, \"!governance\");\n    }\n}\n","license":"MIT OR AGPL-3.0"}},"version":1},"id":1}