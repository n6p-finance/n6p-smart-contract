{"abi":[{"type":"function","name":"allowance","inputs":[{"name":"owner","type":"address","internalType":"address"},{"name":"spender","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"approve","inputs":[{"name":"spender","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"nonpayable"},{"type":"function","name":"balanceOf","inputs":[{"name":"account","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"decimals","inputs":[],"outputs":[{"name":"","type":"uint8","internalType":"uint8"}],"stateMutability":"view"},{"type":"function","name":"totalSupply","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"transfer","inputs":[{"name":"recipient","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"nonpayable"},{"type":"function","name":"transferFrom","inputs":[{"name":"sender","type":"address","internalType":"address"},{"name":"recipient","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"allowance(address,address)":"dd62ed3e","approve(address,uint256)":"095ea7b3","balanceOf(address)":"70a08231","decimals()":"313ce567","totalSupply()":"18160ddd","transfer(address,uint256)":"a9059cbb","transferFrom(address,address,uint256)":"23b872dd"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Interfaces \",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/src/core/RWA/VaultRWA.sol\":\"IERC20\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[\":@openzeppelin/=lib/openzeppelin-contracts/\",\":ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/src/core/RWA/VaultRWA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title Napy Token Vault (Solidity port)\\n * @notice Solidity implementation of contracts/Vault.vy api 0.4.6\\n * @dev This is a direct port focused on preserving behavior and storage layout semantics.\\n */\\n\\n/// @notice Interfaces \\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface IDetailedERC20 is IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n}\\n\\ninterface IStrategy {\\n    function want() external view returns (address);\\n    function vault() external view returns (address);\\n    function isActive() external view returns (bool);\\n    function delegatedAssets() external view returns (uint256);\\n    function estimatedTotalAssets() external view returns (uint256);\\n    function withdraw(uint256 _amount) external returns (uint256 loss);\\n    function migrate(address _newStrategy) external;\\n    function emergencyExit() external view returns (bool);\\n}\\n\\nlibrary MathLib {\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n    uint256 private _status;\\n    constructor() { _status = _NOT_ENTERED; }\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"REENTRANCY\\\");\\n        _status = _ENTERED;\\n        _;\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\n/// @notice this is where the Vault starts\\ncontract Vault is ReentrancyGuard {\\n    using MathLib for uint256;\\n\\n    // Constants\\n    string public constant API_VERSION = \\\"0.4.6\\\";\\n    uint256 public constant MAXIMUM_STRATEGIES = 20;\\n    uint256 public constant DEGRADATION_COEFFICIENT = 1e18;\\n    uint256 public constant MAX_BPS = 10_000;\\n    uint256 public constant SECS_PER_YEAR = 31_556_952; // 365.2425 days\\n    uint256 internal constant MAX_UINT256 = type(uint256).max;\\n\\n    // ERC20 share token metadata\\n    string public name;\\n    string public symbol;\\n    uint256 public decimals; // match underlying decimals\\n\\n    // ERC20 share token accounting\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n    uint256 public totalSupply;\\n\\n    // Roles and core params\\n    IERC20 public token;\\n    address public governance;\\n    address public management;\\n    address public guardian;\\n    address public pendingGovernance;\\n\\n    struct StrategyParams {\\n        uint256 performanceFee;\\n        uint256 activation;\\n        uint256 debtRatio;\\n        uint256 minDebtPerHarvest;\\n        uint256 maxDebtPerHarvest;\\n        uint256 lastReport;\\n        uint256 totalDebt;\\n        uint256 totalGain;\\n        uint256 totalLoss;\\n    }\\n\\n    mapping(address => StrategyParams) public strategies;\\n    address[MAXIMUM_STRATEGIES] public withdrawalQueue;\\n\\n    bool public emergencyShutdown;\\n\\n    uint256 public depositLimit;\\n    uint256 public debtRatio;\\n    uint256 public totalIdle;\\n    uint256 public totalDebt;\\n    uint256 public lastReport;\\n    uint256 public activation;\\n    uint256 public lockedProfit;\\n    uint256 public lockedProfitDegradation; // scaled by 1e18\\n    address public rewards;\\n    uint256 public managementFee;  // bps\\n    uint256 public performanceFee; // bps\\n\\n    // EIP-2612 Permit\\n    mapping(address => uint256) public nonces;\\n    bytes32 public constant DOMAIN_TYPE_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n    bytes32 public constant PERMIT_TYPE_HASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    // Events\\n    event Transfer(address indexed sender, address indexed receiver, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Deposit(address indexed recipient, uint256 shares, uint256 amount);\\n    event Withdraw(address indexed recipient, uint256 shares, uint256 amount);\\n    event Sweep(address indexed token, uint256 amount);\\n    event LockedProfitDegradationUpdated(uint256 value);\\n    event StrategyAdded(address indexed strategy, uint256 debtRatio, uint256 minDebtPerHarvest, uint256 maxDebtPerHarvest, uint256 performanceFee);\\n    event StrategyReported(address indexed strategy, uint256 gain, uint256 loss, uint256 debtPaid, uint256 totalGain, uint256 totalLoss, uint256 totalDebt, uint256 debtAdded, uint256 debtRatio);\\n    event FeeReport(uint256 management_fee, uint256 performance_fee, uint256 strategist_fee, uint256 duration);\\n    event WithdrawFromStrategy(address indexed strategy, uint256 totalDebt, uint256 loss);\\n    event UpdateGovernance(address governance);\\n    event UpdateManagement(address management);\\n    event UpdateRewards(address rewards);\\n    event UpdateDepositLimit(uint256 depositLimit);\\n    event UpdatePerformanceFee(uint256 performanceFee);\\n    event UpdateManagementFee(uint256 managementFee);\\n    event UpdateGuardian(address guardian);\\n    event EmergencyShutdown(bool active);\\n    event UpdateWithdrawalQueue(address[MAXIMUM_STRATEGIES] queue);\\n    event StrategyUpdateDebtRatio(address indexed strategy, uint256 debtRatio);\\n    event StrategyUpdateMinDebtPerHarvest(address indexed strategy, uint256 minDebtPerHarvest);\\n    event StrategyUpdateMaxDebtPerHarvest(address indexed strategy, uint256 maxDebtPerHarvest);\\n    event StrategyUpdatePerformanceFee(address indexed strategy, uint256 performanceFee);\\n    event StrategyMigrated(address indexed oldVersion, address indexed newVersion);\\n    event StrategyRevoked(address indexed strategy);\\n    event StrategyRemovedFromQueue(address indexed strategy);\\n    event StrategyAddedToQueue(address indexed strategy);\\n    event NewPendingGovernance(address indexed pendingGovernance);\\n\\n    // Initialization (replaces Vyper initialize external)\\n    function initialize(\\n        address _token,\\n        address _governance,\\n        address _rewards,\\n        string memory nameOverride,\\n        string memory symbolOverride,\\n        address _guardian,\\n        address _management\\n    ) external {\\n        require(activation == 0, \\\"initialized\\\");\\n        token = IERC20(_token);\\n        if (bytes(nameOverride).length == 0) {\\n            name = string(abi.encodePacked(IDetailedERC20(_token).symbol(), \\\" nVault\\\"));\\n        } else {\\n            name = nameOverride;\\n        }\\n        if (bytes(symbolOverride).length == 0) {\\n            symbol = string(abi.encodePacked(\\\"nV\\\", IDetailedERC20(_token).symbol()));\\n        } else {\\n            symbol = symbolOverride;\\n        }\\n        uint8 dec = IERC20(_token).decimals();\\n        require(uint256(dec) < 256, \\\"dec\\\");\\n        decimals = uint256(dec);\\n\\n        governance = _governance;\\n        emit UpdateGovernance(_governance);\\n        management = _management;\\n        emit UpdateManagement(_management);\\n        rewards = _rewards;\\n        emit UpdateRewards(_rewards);\\n        guardian = _guardian;\\n        emit UpdateGuardian(_guardian);\\n        performanceFee = 1000; // 10%\\n        emit UpdatePerformanceFee(1000);\\n        managementFee = 200; // 2%\\n        emit UpdateManagementFee(200);\\n        lastReport = block.timestamp;\\n        activation = block.timestamp;\\n        lockedProfitDegradation = (DEGRADATION_COEFFICIENT * 46) / 1e6; // ~6 hours in seconds-scale\\n    }\\n\\n    // EIP-712 domain separator\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                DOMAIN_TYPE_HASH,\\n                keccak256(bytes(\\\"napy Vault\\\")),\\n                keccak256(bytes(API_VERSION)),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32) { return _domainSeparatorV4(); }\\n    function apiVersion() external pure returns (string memory) { return API_VERSION; }\\n\\n    // Admin setters\\n    modifier onlyGov() { require(msg.sender == governance, \\\"gov\\\"); _; }\\n    modifier onlyGovOrMgmt() { require(msg.sender == governance || msg.sender == management, \\\"auth\\\"); _; }\\n\\n    function setName(string calldata _name) external onlyGov { name = _name; }\\n    function setSymbol(string calldata _symbol) external onlyGov { symbol = _symbol; }\\n\\n    function setGovernance(address _gov) external onlyGov {\\n        pendingGovernance = _gov;\\n        emit NewPendingGovernance(_gov);\\n    }\\n    function acceptGovernance() external {\\n        require(msg.sender == pendingGovernance, \\\"not pending\\\");\\n        governance = msg.sender;\\n        emit UpdateGovernance(msg.sender);\\n    }\\n    function setManagement(address _mgmt) external onlyGov { management = _mgmt; emit UpdateManagement(_mgmt); }\\n    function setRewards(address _rewards) external onlyGov {\\n        require(_rewards != address(0) && _rewards != address(this), \\\"rewards\\\");\\n        rewards = _rewards; emit UpdateRewards(_rewards);\\n    }\\n    function setLockedProfitDegradation(uint256 degradation) external onlyGov {\\n        require(degradation <= DEGRADATION_COEFFICIENT, \\\"deg\\\");\\n        lockedProfitDegradation = degradation; emit LockedProfitDegradationUpdated(degradation);\\n    }\\n    function setDepositLimit(uint256 limit) external onlyGov { \\n        depositLimit = limit; \\n        emit UpdateDepositLimit(limit); }\\n    function setPerformanceFee(uint256 fee) external onlyGov { require(fee <= MAX_BPS/2, \\\"fee\\\"); performanceFee = fee; emit UpdatePerformanceFee(fee); }\\n    function setManagementFee(uint256 fee) external onlyGov { require(fee <= MAX_BPS, \\\"fee\\\"); managementFee = fee; emit UpdateManagementFee(fee); }\\n    function setGuardian(address _guardian) external { require(msg.sender == guardian || msg.sender == governance, \\\"auth\\\"); guardian = _guardian; emit UpdateGuardian(_guardian); }\\n    function setEmergencyShutdown(bool active) external {\\n        if (active) { require(msg.sender == guardian || msg.sender == governance, \\\"auth\\\"); }\\n        else { require(msg.sender == governance, \\\"gov\\\"); }\\n        emergencyShutdown = active; emit EmergencyShutdown(active);\\n    }\\n\\n    function setWithdrawalQueue(address[MAXIMUM_STRATEGIES] calldata queue) external onlyGovOrMgmt {\\n        // Validate and reorder only existing entries\\n        address[MAXIMUM_STRATEGIES] memory oldq = withdrawalQueue;\\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) {\\n            if (queue[i] == address(0)) {\\n                require(oldq[i] == address(0), \\\"no extend\\\");\\n                break;\\n            }\\n            require(oldq[i] != address(0), \\\"no add\\\");\\n            require(strategies[queue[i]].activation > 0, \\\"unknown\\\");\\n            bool exists = false;\\n            for (uint256 j=0;j<MAXIMUM_STRATEGIES;j++) {\\n                if (queue[j] == address(0)) { exists = true; break; }\\n                if (queue[i] == oldq[j]) { exists = true; }\\n                if (j <= i) continue;\\n                require(queue[i] != queue[j], \\\"dup\\\");\\n            }\\n            require(exists, \\\"exists\\\");\\n            withdrawalQueue[i] = queue[i]; // Update withdraw queue\\n        }\\n        emit UpdateWithdrawalQueue(queue);\\n    }\\n\\n    // Safe ERC20 helpers\\n    function _safeTransfer(address _token, address to, uint256 amount) internal {\\n        (bool ok, bytes memory data) = _token.call(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", to, amount));\\n        require(ok && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER\\\");\\n    }\\n    function _safeTransferFrom(address _token, address from, address to, uint256 amount) internal {\\n        (bool ok, bytes memory data) = _token.call(abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", from, to, amount));\\n        require(ok && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM\\\");\\n    }\\n\\n    // ERC20 share logic\\n    function _transfer(address from, address to, uint256 amount) internal {\\n        require(to != address(0) && to != address(this), \\\"bad to\\\");\\n        balanceOf[from] -= amount;\\n        balanceOf[to] += amount;\\n        emit Transfer(from, to, amount);\\n    }\\n    function transfer(address to, uint256 amount) external returns (bool) { _transfer(msg.sender, to, amount); return true; }\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender];\\n        if (allowed != type(uint256).max) {\\n            allowance[from][msg.sender] = allowed - amount; // Allowance to 'to' \\n            emit Approval(from, msg.sender, allowance[from][msg.sender]);\\n        }\\n        _transfer(from, to, amount); return true;\\n    }\\n    function approve(address spender, uint256 amount) external returns (bool) { allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; }\\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) { \\n        allowance[msg.sender][spender] += amount; \\n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]); \\n        return true; }\\n\\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) { \\n        allowance[msg.sender][spender] -= amount; \\n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]); \\n        return true; }\\n\\n    // EIP-2612 permit See https://eips.ethereum.org/EIPS/eip-2612.\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes calldata signature) external returns (bool) {\\n        require(owner != address(0), \\\"owner\\\");\\n        require(deadline >= block.timestamp, \\\"expired\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _domainSeparatorV4(),\\n                keccak256(abi.encode(\\n                    PERMIT_TYPE_HASH, \\n                    owner, \\n                    spender, \\n                    value, \\n                    nonces[owner], \\n                    deadline))\\n            )\\n        );\\n        (bytes32 r, bytes32 s, uint8 v) = _splitSig(signature);\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory == owner, \\\"sig\\\");\\n        allowance[owner][spender] = value;\\n        nonces[owner] += 1;\\n        emit Approval(owner, spender, value);\\n        return true;\\n    }\\n    function _splitSig(bytes calldata sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        require(sig.length == 65, \\\"siglen\\\");\\n        assembly {\\n            r := calldataload(sig.offset)\\n            s := calldataload(add(sig.offset, 32))\\n            v := byte(0, calldataload(add(sig.offset, 64)))\\n        }\\n    }\\n\\n    // View helpers\\n    function _totalAssets() internal view returns (uint256) { \\n        return totalIdle + totalDebt; \\n        }\\n        \\n    function totalAssets() external view returns (uint256) { return _totalAssets(); }\\n\\n    function _calculateLockedProfit() internal view returns (uint256) {\\n        uint256 lockedFundsRatio = (block.timestamp - lastReport) * lockedProfitDegradation;\\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\\n            uint256 lp = lockedProfit;\\n            return lp - ((lockedFundsRatio * lp) / DEGRADATION_COEFFICIENT);\\n        } else {\\n            return 0;\\n        }\\n    }\\n    function _freeFunds() internal view returns (uint256) { return _totalAssets() - _calculateLockedProfit(); }\\n\\n    function _issueSharesForAmount(address to, uint256 amount) internal returns (uint256 shares) {\\n        uint256 ts = totalSupply;\\n        if (ts > 0) {\\n            shares = (amount * ts) / _freeFunds();\\n        } else {\\n            shares = amount;\\n        }\\n        require(shares != 0, \\\"shares\\\");\\n        totalSupply = ts + shares;\\n        balanceOf[to] += shares;\\n        emit Transfer(address(0), to, shares);\\n    }\\n\\n    // NOTE: This is internal function so if we want to test it we want to make a wrapper\\n    function _shareValue(uint256 shares) internal view returns (uint256) {\\n        if (totalSupply == 0) return shares;\\n        return (shares * _freeFunds()) / totalSupply;\\n    }\\n\\n    function _shareValuePublic_(uint256 shares) external view returns (uint256) {\\n        return _shareValue(shares);\\n    }\\n\\n    // NOTE: This is internal function so if we want to test it we want to make a wrapper\\n    function _sharesForAmount(uint256 amount) internal view returns (uint256) {\\n        uint256 ff = _freeFunds();\\n        if (ff > 0) return (amount * totalSupply) / ff; else return 0;\\n    }\\n\\n    function _sharesForAmountPublic_(uint256 amount) external view returns (uint256) {\\n        return _sharesForAmount(amount);\\n    }\\n\\n    function maxAvailableShares() external view returns (uint256) {\\n        uint256 shares = _sharesForAmount(totalIdle);\\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) {\\n            address s = withdrawalQueue[i];\\n            if (s == address(0)) break;\\n            shares += _sharesForAmount(strategies[s].totalDebt);\\n        }\\n        return shares;\\n    }\\n\\n    // Core actions\\n    function deposit(uint256 _amount, address recipient) external nonReentrant returns (uint256) {\\n        if (recipient == address(0)) recipient = msg.sender;\\n        require(!emergencyShutdown, \\\"shutdown\\\");\\n        require(recipient != address(this), \\\"recipient\\\");\\n\\n        uint256 amount = _amount;\\n        if (amount == MAX_UINT256) {\\n            uint256 maxDep = depositLimit > _totalAssets() ? (depositLimit - _totalAssets()) : 0;\\n            amount = MathLib.min(maxDep, IERC20(token).balanceOf(msg.sender));\\n        } else {\\n            if (depositLimit > 0) {\\n                require(_totalAssets() + amount <= depositLimit, \\\"limit\\\");\\n            }\\n        }\\n        require(amount > 0, \\\"amount\\\");\\n\\n        uint256 shares = _issueSharesForAmount(recipient, amount);\\n        _safeTransferFrom(address(token), msg.sender, address(this), amount);\\n        totalIdle += amount;\\n        emit Deposit(recipient, shares, amount);\\n        return shares;\\n    }\\n\\n    function withdraw(uint256 maxShares, address recipient, uint256 maxLoss) external nonReentrant returns (uint256) {\\n        if (recipient == address(0)) recipient = msg.sender;\\n        require(maxLoss <= MAX_BPS, \\\"loss\\\");\\n        uint256 shares = maxShares == MAX_UINT256 ? balanceOf[msg.sender] : maxShares;\\n        require(shares > 0 && shares <= balanceOf[msg.sender], \\\"shares\\\");\\n\\n        uint256 value = _shareValue(shares);\\n        uint256 vaultBalance = totalIdle;\\n        uint256 totalLoss = 0;\\n\\n        if (value > vaultBalance) {\\n            for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) {\\n                address strat = withdrawalQueue[i];\\n                if (strat == address(0)) break;\\n                if (value <= vaultBalance) break;\\n                uint256 amountNeeded = value - vaultBalance;\\n                amountNeeded = MathLib.min(amountNeeded, strategies[strat].totalDebt);\\n                if (amountNeeded == 0) continue;\\n                uint256 pre = IERC20(token).balanceOf(address(this));\\n                uint256 loss = IStrategy(strat).withdraw(amountNeeded);\\n                uint256 withdrawn = IERC20(token).balanceOf(address(this)) - pre;\\n                vaultBalance += withdrawn;\\n                if (loss > 0) {\\n                    value -= loss; totalLoss += loss; _reportLoss(strat, loss);\\n                }\\n                strategies[strat].totalDebt -= withdrawn; totalDebt -= withdrawn;\\n                emit WithdrawFromStrategy(strat, strategies[strat].totalDebt, loss);\\n            }\\n            totalIdle = vaultBalance;\\n            if (value > vaultBalance) {\\n                value = vaultBalance;\\n                shares = _sharesForAmount(value + totalLoss);\\n            }\\n            require(totalLoss <= (maxLoss * (value + totalLoss)) / MAX_BPS, \\\"excess loss\\\");\\n        }\\n\\n        totalSupply -= shares;\\n        balanceOf[msg.sender] -= shares;\\n        emit Transfer(msg.sender, address(0), shares);\\n\\n        totalIdle -= value;\\n        _safeTransfer(address(token), recipient, value);\\n        emit Withdraw(recipient, shares, value);\\n        return value;\\n    }\\n\\n    // Price per shares\\n    function pricePerShare() external view returns (uint256) { return _shareValue(10 ** decimals); }\\n\\n    // Queue organize helper\\n    function _organizeWithdrawalQueue() internal {\\n        uint256 offset;\\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) {\\n            address s = withdrawalQueue[i];\\n            if (s == address(0)) { offset += 1; }\\n            else if (offset > 0) { withdrawalQueue[i - offset] = s; withdrawalQueue[i] = address(0); }\\n        }\\n    }\\n\\n    // Strategy management\\n    function addStrategy(address strategy, uint256 _debtRatio, uint256 minDebtPerHarvest, uint256 maxDebtPerHarvest, uint256 _performanceFee) external onlyGov {\\n        require(withdrawalQueue[MAXIMUM_STRATEGIES - 1] == address(0), \\\"full\\\");\\n        require(!emergencyShutdown, \\\"shutdown\\\");\\n        require(strategy != address(0), \\\"addr\\\");\\n        require(strategies[strategy].activation == 0, \\\"exists\\\");\\n        require(IStrategy(strategy).vault() == address(this), \\\"vault\\\");\\n        require(IStrategy(strategy).want() == address(token), \\\"want\\\");\\n        require(debtRatio + _debtRatio <= MAX_BPS, \\\"ratio\\\");\\n        require(minDebtPerHarvest <= maxDebtPerHarvest, \\\"range\\\");\\n        require(_performanceFee <= MAX_BPS/2, \\\"pf\\\");\\n\\n        strategies[strategy] = StrategyParams({\\n            performanceFee: _performanceFee,\\n            activation: block.timestamp,\\n            debtRatio: _debtRatio,\\n            minDebtPerHarvest: minDebtPerHarvest,\\n            maxDebtPerHarvest: maxDebtPerHarvest,\\n            lastReport: block.timestamp,\\n            totalDebt: 0,\\n            totalGain: 0,\\n            totalLoss: 0\\n        });\\n        emit StrategyAdded(strategy, _debtRatio, minDebtPerHarvest, maxDebtPerHarvest, _performanceFee);\\n        debtRatio += _debtRatio;\\n        withdrawalQueue[MAXIMUM_STRATEGIES - 1] = strategy;\\n        _organizeWithdrawalQueue();\\n    }\\n\\n    function updateStrategyDebtRatio(address strategy, uint256 _debtRatio) external onlyGovOrMgmt {\\n        require(strategies[strategy].activation > 0, \\\"unknown\\\");\\n        require(!IStrategy(strategy).emergencyExit(), \\\"emexit\\\");\\n        debtRatio -= strategies[strategy].debtRatio;\\n        strategies[strategy].debtRatio = _debtRatio;\\n        debtRatio += _debtRatio;\\n        require(debtRatio <= MAX_BPS, \\\"ratio\\\");\\n        emit StrategyUpdateDebtRatio(strategy, _debtRatio);\\n    }\\n\\n    function updateStrategyMinDebtPerHarvest(address strategy, uint256 m) external onlyGovOrMgmt {\\n        require(strategies[strategy].activation > 0, \\\"unknown\\\");\\n        require(strategies[strategy].maxDebtPerHarvest >= m, \\\"gt max\\\");\\n        strategies[strategy].minDebtPerHarvest = m;\\n        emit StrategyUpdateMinDebtPerHarvest(strategy, m);\\n    }\\n    function updateStrategyMaxDebtPerHarvest(address strategy, uint256 m) external onlyGovOrMgmt {\\n        require(strategies[strategy].activation > 0, \\\"unknown\\\");\\n        require(strategies[strategy].minDebtPerHarvest <= m, \\\"lt min\\\");\\n        strategies[strategy].maxDebtPerHarvest = m;\\n        emit StrategyUpdateMaxDebtPerHarvest(strategy, m);\\n    }\\n    function updateStrategyPerformanceFee(address strategy, uint256 pf) external onlyGov {\\n        require(pf <= MAX_BPS/2, \\\"pf\\\");\\n        require(strategies[strategy].activation > 0, \\\"unknown\\\");\\n        strategies[strategy].performanceFee = pf;\\n        emit StrategyUpdatePerformanceFee(strategy, pf);\\n    }\\n\\n    function _revokeStrategy(address strategy) internal {\\n        debtRatio -= strategies[strategy].debtRatio;\\n        strategies[strategy].debtRatio = 0;\\n        emit StrategyRevoked(strategy);\\n    }\\n\\n    function migrateStrategy(address oldVersion, address newVersion) external onlyGov {\\n        require(newVersion != address(0), \\\"addr\\\");\\n        require(strategies[oldVersion].activation > 0, \\\"old\\\");\\n        require(strategies[newVersion].activation == 0, \\\"new\\\");\\n        StrategyParams memory s = strategies[oldVersion];\\n        _revokeStrategy(oldVersion);\\n        debtRatio += s.debtRatio;\\n        strategies[oldVersion].totalDebt = 0;\\n        strategies[newVersion] = StrategyParams({\\n            performanceFee: s.performanceFee,\\n            activation: s.lastReport,\\n            debtRatio: s.debtRatio,\\n            minDebtPerHarvest: s.minDebtPerHarvest,\\n            maxDebtPerHarvest: s.maxDebtPerHarvest,\\n            lastReport: s.lastReport,\\n            totalDebt: s.totalDebt,\\n            totalGain: 0,\\n            totalLoss: 0\\n        });\\n        IStrategy(oldVersion).migrate(newVersion);\\n        emit StrategyMigrated(oldVersion, newVersion);\\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) { if (withdrawalQueue[i] == oldVersion) { withdrawalQueue[i] = newVersion; return; } }\\n    }\\n\\n    function revokeStrategy(address strategy) external {\\n        require(msg.sender == strategy || msg.sender == governance || msg.sender == guardian, \\\"auth\\\");\\n        require(strategies[strategy].debtRatio != 0, \\\"zero\\\");\\n        _revokeStrategy(strategy);\\n    }\\n\\n    function addStrategyToQueue(address strategy) external onlyGovOrMgmt {\\n        require(strategies[strategy].activation > 0, \\\"unknown\\\");\\n        uint256 lastIdx;\\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) { address s = withdrawalQueue[i]; if (s == address(0)) break; require(s != strategy, \\\"dup\\\"); lastIdx++; }\\n        require(lastIdx < MAXIMUM_STRATEGIES, \\\"full\\\");\\n        withdrawalQueue[MAXIMUM_STRATEGIES - 1] = strategy;\\n        _organizeWithdrawalQueue();\\n        emit StrategyAddedToQueue(strategy);\\n    }\\n\\n    function removeStrategyFromQueue(address strategy) external onlyGovOrMgmt {\\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) { if (withdrawalQueue[i] == strategy) { withdrawalQueue[i] = address(0); _organizeWithdrawalQueue(); emit StrategyRemovedFromQueue(strategy); return; } }\\n        revert(\\\"not in queue\\\");\\n    }\\n\\n    // Debts and credit\\n    function _debtOutstanding(address strategy) internal view returns (uint256) {\\n        if (debtRatio == 0) return strategies[strategy].totalDebt;\\n        uint256 strategyDebtLimit = (strategies[strategy].debtRatio * _totalAssets()) / MAX_BPS;\\n        uint256 strategyTotalDebt = strategies[strategy].totalDebt;\\n        if (emergencyShutdown) return strategyTotalDebt;\\n        else if (strategyTotalDebt <= strategyDebtLimit) return 0; else return strategyTotalDebt - strategyDebtLimit;\\n    }\\n    function debtOutstanding(address strategy) external view returns (uint256) { if (strategy == address(0)) strategy = msg.sender; return _debtOutstanding(strategy); }\\n\\n    function _creditAvailable(address strategy) internal view returns (uint256) {\\n        if (emergencyShutdown) return 0;\\n        uint256 vTotalAssets = _totalAssets();\\n        uint256 vDebtLimit = (debtRatio * vTotalAssets) / MAX_BPS;\\n        uint256 vTotalDebt = totalDebt;\\n        uint256 sDebtLimit = (strategies[strategy].debtRatio * vTotalAssets) / MAX_BPS;\\n        uint256 sTotalDebt = strategies[strategy].totalDebt;\\n        uint256 sMin = strategies[strategy].minDebtPerHarvest;\\n        uint256 sMax = strategies[strategy].maxDebtPerHarvest;\\n        if (sDebtLimit <= sTotalDebt || vDebtLimit <= vTotalDebt) return 0;\\n        uint256 available = sDebtLimit - sTotalDebt;\\n        available = MathLib.min(available, vDebtLimit - vTotalDebt);\\n        available = MathLib.min(available, totalIdle);\\n        if (available < sMin) return 0; else return MathLib.min(available, sMax);\\n    }\\n    function creditAvailable(address strategy) external view returns (uint256) { if (strategy == address(0)) strategy = msg.sender; return _creditAvailable(strategy); }\\n\\n    function _expectedReturn(address strategy) internal view returns (uint256) {\\n        uint256 last = strategies[strategy].lastReport;\\n        uint256 timeSince = block.timestamp - last;\\n        uint256 totalHarvestTime = last - strategies[strategy].activation;\\n        if (timeSince > 0 && totalHarvestTime > 0 && IStrategy(strategy).isActive()) {\\n            return (strategies[strategy].totalGain * timeSince) / totalHarvestTime;\\n        } else { return 0; }\\n    }\\n    function expectedReturn(address strategy) external view returns (uint256) { if (strategy == address(0)) strategy = msg.sender; return _expectedReturn(strategy); }\\n\\n    // Fees and reporting\\n    function _assessFees(address strategy, uint256 gain) internal returns (uint256 total_fee) {\\n        if (strategies[strategy].activation == block.timestamp) return 0;\\n        uint256 duration = block.timestamp - strategies[strategy].lastReport; require(duration != 0, \\\"same block\\\");\\n        if (gain == 0) return 0;\\n        uint256 management_fee = ((strategies[strategy].totalDebt - IStrategy(strategy).delegatedAssets()) * duration * managementFee) / MAX_BPS / SECS_PER_YEAR;\\n        uint256 strategist_fee = (gain * strategies[strategy].performanceFee) / MAX_BPS;\\n        uint256 performance_fee_ = (gain * performanceFee) / MAX_BPS;\\n        total_fee = management_fee + strategist_fee + performance_fee_;\\n        if (total_fee > gain) total_fee = gain;\\n        if (total_fee > 0) {\\n            uint256 reward = _issueSharesForAmount(address(this), total_fee);\\n            if (strategist_fee > 0) {\\n                uint256 strategist_reward = (strategist_fee * reward) / total_fee;\\n                _transfer(address(this), strategy, strategist_reward);\\n            }\\n            uint256 bal = balanceOf[address(this)];\\n            if (bal > 0) _transfer(address(this), rewards, bal);\\n        }\\n        emit FeeReport(management_fee, performance_fee_, strategist_fee, duration);\\n    }\\n\\n    function report(uint256 gain, uint256 loss, uint256 _debtPayment) external returns (uint256) {\\n        require(strategies[msg.sender].activation > 0, \\\"unknown\\\");\\n        require(IERC20(token).balanceOf(msg.sender) >= gain + _debtPayment, \\\"balance\\\");\\n        if (loss > 0) { _reportLoss(msg.sender, loss); }\\n        uint256 totalFees = _assessFees(msg.sender, gain);\\n        strategies[msg.sender].totalGain += gain;\\n        uint256 credit = _creditAvailable(msg.sender);\\n        uint256 debt = _debtOutstanding(msg.sender);\\n        uint256 debtPayment = MathLib.min(_debtPayment, debt);\\n        if (debtPayment > 0) { strategies[msg.sender].totalDebt -= debtPayment; totalDebt -= debtPayment; debt -= debtPayment; }\\n        if (credit > 0) { strategies[msg.sender].totalDebt += credit; totalDebt += credit; }\\n        uint256 totalAvail = gain + debtPayment;\\n        if (totalAvail < credit) { totalIdle -= (credit - totalAvail); _safeTransfer(address(token), msg.sender, credit - totalAvail); }\\n        else if (totalAvail > credit) { totalIdle += (totalAvail - credit); _safeTransferFrom(address(token), msg.sender, address(this), totalAvail - credit); }\\n        uint256 lockedProfitBeforeLoss = _calculateLockedProfit() + gain - totalFees;\\n        if (lockedProfitBeforeLoss > loss) lockedProfit = lockedProfitBeforeLoss - loss; else lockedProfit = 0;\\n        strategies[msg.sender].lastReport = block.timestamp; lastReport = block.timestamp;\\n        emit StrategyReported(msg.sender, gain, loss, debtPayment, strategies[msg.sender].totalGain, strategies[msg.sender].totalLoss, strategies[msg.sender].totalDebt, credit, strategies[msg.sender].debtRatio);\\n        if (strategies[msg.sender].debtRatio == 0 || emergencyShutdown) { return IStrategy(msg.sender).estimatedTotalAssets(); } else { return debt; }\\n    }\\n\\n    function _reportLoss(address strategy, uint256 loss) internal {\\n        uint256 totalDebt_ = strategies[strategy].totalDebt; require(totalDebt_ >= loss, \\\"loss\\\");\\n        if (debtRatio != 0) {\\n            uint256 ratio_change = 0;\\n            if (totalDebt > 0) {\\n                ratio_change = MathLib.min((loss * debtRatio) / totalDebt, strategies[strategy].debtRatio);\\n            }\\n            strategies[strategy].debtRatio -= ratio_change; debtRatio -= ratio_change;\\n        }\\n        strategies[strategy].totalLoss += loss;\\n        strategies[strategy].totalDebt = totalDebt_ - loss; totalDebt -= loss;\\n    }\\n\\n    function availableDepositLimit() external view returns (uint256) { return depositLimit > _totalAssets() ? depositLimit - _totalAssets() : 0; }\\n\\n    // The sweep() function lets the vault governance recover (sweep out) unexpected or leftover tokens that\\n    //             shouldn\\u2019t be in the vault \\u2014 but protects the main vault asset.\\n    function sweep(address _token, uint256 amount) external onlyGov {\\n        uint256 value = amount;\\n        if (value == MAX_UINT256) { value = IERC20(_token).balanceOf(address(this)); }\\n        if (_token == address(token)) { value = IERC20(_token).balanceOf(address(this)) - totalIdle; }\\n        emit Sweep(_token, value);\\n        _safeTransfer(_token, governance, value);\\n    }\\n}\\n\\n\\n\",\"keccak256\":\"0x5befe2f396daac7005f987cc1703bee87fe3b45071a2312e054deeb4ff164080\",\"license\":\"MIT OR AGPL-3.0\"}},\"version\":1}","metadata":{"compiler":{"version":"0.8.30+commit.73712a01"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"stateMutability":"view","type":"function","name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"stateMutability":"view","type":"function","name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}]}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/"],"optimizer":{"enabled":true,"runs":1},"metadata":{"useLiteralContent":true,"bytecodeHash":"ipfs"},"compilationTarget":{"contracts/src/core/RWA/VaultRWA.sol":"IERC20"},"evmVersion":"shanghai","libraries":{},"viaIR":true},"sources":{"contracts/src/core/RWA/VaultRWA.sol":{"keccak256":"0x5befe2f396daac7005f987cc1703bee87fe3b45071a2312e054deeb4ff164080","urls":[],"content":"// SPDX-License-Identifier: MIT OR AGPL-3.0\npragma solidity ^0.8.20;\n\n/**\n * @title Napy Token Vault (Solidity port)\n * @notice Solidity implementation of contracts/Vault.vy api 0.4.6\n * @dev This is a direct port focused on preserving behavior and storage layout semantics.\n */\n\n/// @notice Interfaces \ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function decimals() external view returns (uint8);\n}\n\ninterface IDetailedERC20 is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n}\n\ninterface IStrategy {\n    function want() external view returns (address);\n    function vault() external view returns (address);\n    function isActive() external view returns (bool);\n    function delegatedAssets() external view returns (uint256);\n    function estimatedTotalAssets() external view returns (uint256);\n    function withdraw(uint256 _amount) external returns (uint256 loss);\n    function migrate(address _newStrategy) external;\n    function emergencyExit() external view returns (bool);\n}\n\nlibrary MathLib {\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    constructor() { _status = _NOT_ENTERED; }\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"REENTRANCY\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\n/// @notice this is where the Vault starts\ncontract Vault is ReentrancyGuard {\n    using MathLib for uint256;\n\n    // Constants\n    string public constant API_VERSION = \"0.4.6\";\n    uint256 public constant MAXIMUM_STRATEGIES = 20;\n    uint256 public constant DEGRADATION_COEFFICIENT = 1e18;\n    uint256 public constant MAX_BPS = 10_000;\n    uint256 public constant SECS_PER_YEAR = 31_556_952; // 365.2425 days\n    uint256 internal constant MAX_UINT256 = type(uint256).max;\n\n    // ERC20 share token metadata\n    string public name;\n    string public symbol;\n    uint256 public decimals; // match underlying decimals\n\n    // ERC20 share token accounting\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 public totalSupply;\n\n    // Roles and core params\n    IERC20 public token;\n    address public governance;\n    address public management;\n    address public guardian;\n    address public pendingGovernance;\n\n    struct StrategyParams {\n        uint256 performanceFee;\n        uint256 activation;\n        uint256 debtRatio;\n        uint256 minDebtPerHarvest;\n        uint256 maxDebtPerHarvest;\n        uint256 lastReport;\n        uint256 totalDebt;\n        uint256 totalGain;\n        uint256 totalLoss;\n    }\n\n    mapping(address => StrategyParams) public strategies;\n    address[MAXIMUM_STRATEGIES] public withdrawalQueue;\n\n    bool public emergencyShutdown;\n\n    uint256 public depositLimit;\n    uint256 public debtRatio;\n    uint256 public totalIdle;\n    uint256 public totalDebt;\n    uint256 public lastReport;\n    uint256 public activation;\n    uint256 public lockedProfit;\n    uint256 public lockedProfitDegradation; // scaled by 1e18\n    address public rewards;\n    uint256 public managementFee;  // bps\n    uint256 public performanceFee; // bps\n\n    // EIP-2612 Permit\n    mapping(address => uint256) public nonces;\n    bytes32 public constant DOMAIN_TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 public constant PERMIT_TYPE_HASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    // Events\n    event Transfer(address indexed sender, address indexed receiver, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Deposit(address indexed recipient, uint256 shares, uint256 amount);\n    event Withdraw(address indexed recipient, uint256 shares, uint256 amount);\n    event Sweep(address indexed token, uint256 amount);\n    event LockedProfitDegradationUpdated(uint256 value);\n    event StrategyAdded(address indexed strategy, uint256 debtRatio, uint256 minDebtPerHarvest, uint256 maxDebtPerHarvest, uint256 performanceFee);\n    event StrategyReported(address indexed strategy, uint256 gain, uint256 loss, uint256 debtPaid, uint256 totalGain, uint256 totalLoss, uint256 totalDebt, uint256 debtAdded, uint256 debtRatio);\n    event FeeReport(uint256 management_fee, uint256 performance_fee, uint256 strategist_fee, uint256 duration);\n    event WithdrawFromStrategy(address indexed strategy, uint256 totalDebt, uint256 loss);\n    event UpdateGovernance(address governance);\n    event UpdateManagement(address management);\n    event UpdateRewards(address rewards);\n    event UpdateDepositLimit(uint256 depositLimit);\n    event UpdatePerformanceFee(uint256 performanceFee);\n    event UpdateManagementFee(uint256 managementFee);\n    event UpdateGuardian(address guardian);\n    event EmergencyShutdown(bool active);\n    event UpdateWithdrawalQueue(address[MAXIMUM_STRATEGIES] queue);\n    event StrategyUpdateDebtRatio(address indexed strategy, uint256 debtRatio);\n    event StrategyUpdateMinDebtPerHarvest(address indexed strategy, uint256 minDebtPerHarvest);\n    event StrategyUpdateMaxDebtPerHarvest(address indexed strategy, uint256 maxDebtPerHarvest);\n    event StrategyUpdatePerformanceFee(address indexed strategy, uint256 performanceFee);\n    event StrategyMigrated(address indexed oldVersion, address indexed newVersion);\n    event StrategyRevoked(address indexed strategy);\n    event StrategyRemovedFromQueue(address indexed strategy);\n    event StrategyAddedToQueue(address indexed strategy);\n    event NewPendingGovernance(address indexed pendingGovernance);\n\n    // Initialization (replaces Vyper initialize external)\n    function initialize(\n        address _token,\n        address _governance,\n        address _rewards,\n        string memory nameOverride,\n        string memory symbolOverride,\n        address _guardian,\n        address _management\n    ) external {\n        require(activation == 0, \"initialized\");\n        token = IERC20(_token);\n        if (bytes(nameOverride).length == 0) {\n            name = string(abi.encodePacked(IDetailedERC20(_token).symbol(), \" nVault\"));\n        } else {\n            name = nameOverride;\n        }\n        if (bytes(symbolOverride).length == 0) {\n            symbol = string(abi.encodePacked(\"nV\", IDetailedERC20(_token).symbol()));\n        } else {\n            symbol = symbolOverride;\n        }\n        uint8 dec = IERC20(_token).decimals();\n        require(uint256(dec) < 256, \"dec\");\n        decimals = uint256(dec);\n\n        governance = _governance;\n        emit UpdateGovernance(_governance);\n        management = _management;\n        emit UpdateManagement(_management);\n        rewards = _rewards;\n        emit UpdateRewards(_rewards);\n        guardian = _guardian;\n        emit UpdateGuardian(_guardian);\n        performanceFee = 1000; // 10%\n        emit UpdatePerformanceFee(1000);\n        managementFee = 200; // 2%\n        emit UpdateManagementFee(200);\n        lastReport = block.timestamp;\n        activation = block.timestamp;\n        lockedProfitDegradation = (DEGRADATION_COEFFICIENT * 46) / 1e6; // ~6 hours in seconds-scale\n    }\n\n    // EIP-712 domain separator\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_TYPE_HASH,\n                keccak256(bytes(\"napy Vault\")),\n                keccak256(bytes(API_VERSION)),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32) { return _domainSeparatorV4(); }\n    function apiVersion() external pure returns (string memory) { return API_VERSION; }\n\n    // Admin setters\n    modifier onlyGov() { require(msg.sender == governance, \"gov\"); _; }\n    modifier onlyGovOrMgmt() { require(msg.sender == governance || msg.sender == management, \"auth\"); _; }\n\n    function setName(string calldata _name) external onlyGov { name = _name; }\n    function setSymbol(string calldata _symbol) external onlyGov { symbol = _symbol; }\n\n    function setGovernance(address _gov) external onlyGov {\n        pendingGovernance = _gov;\n        emit NewPendingGovernance(_gov);\n    }\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"not pending\");\n        governance = msg.sender;\n        emit UpdateGovernance(msg.sender);\n    }\n    function setManagement(address _mgmt) external onlyGov { management = _mgmt; emit UpdateManagement(_mgmt); }\n    function setRewards(address _rewards) external onlyGov {\n        require(_rewards != address(0) && _rewards != address(this), \"rewards\");\n        rewards = _rewards; emit UpdateRewards(_rewards);\n    }\n    function setLockedProfitDegradation(uint256 degradation) external onlyGov {\n        require(degradation <= DEGRADATION_COEFFICIENT, \"deg\");\n        lockedProfitDegradation = degradation; emit LockedProfitDegradationUpdated(degradation);\n    }\n    function setDepositLimit(uint256 limit) external onlyGov { \n        depositLimit = limit; \n        emit UpdateDepositLimit(limit); }\n    function setPerformanceFee(uint256 fee) external onlyGov { require(fee <= MAX_BPS/2, \"fee\"); performanceFee = fee; emit UpdatePerformanceFee(fee); }\n    function setManagementFee(uint256 fee) external onlyGov { require(fee <= MAX_BPS, \"fee\"); managementFee = fee; emit UpdateManagementFee(fee); }\n    function setGuardian(address _guardian) external { require(msg.sender == guardian || msg.sender == governance, \"auth\"); guardian = _guardian; emit UpdateGuardian(_guardian); }\n    function setEmergencyShutdown(bool active) external {\n        if (active) { require(msg.sender == guardian || msg.sender == governance, \"auth\"); }\n        else { require(msg.sender == governance, \"gov\"); }\n        emergencyShutdown = active; emit EmergencyShutdown(active);\n    }\n\n    function setWithdrawalQueue(address[MAXIMUM_STRATEGIES] calldata queue) external onlyGovOrMgmt {\n        // Validate and reorder only existing entries\n        address[MAXIMUM_STRATEGIES] memory oldq = withdrawalQueue;\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) {\n            if (queue[i] == address(0)) {\n                require(oldq[i] == address(0), \"no extend\");\n                break;\n            }\n            require(oldq[i] != address(0), \"no add\");\n            require(strategies[queue[i]].activation > 0, \"unknown\");\n            bool exists = false;\n            for (uint256 j=0;j<MAXIMUM_STRATEGIES;j++) {\n                if (queue[j] == address(0)) { exists = true; break; }\n                if (queue[i] == oldq[j]) { exists = true; }\n                if (j <= i) continue;\n                require(queue[i] != queue[j], \"dup\");\n            }\n            require(exists, \"exists\");\n            withdrawalQueue[i] = queue[i]; // Update withdraw queue\n        }\n        emit UpdateWithdrawalQueue(queue);\n    }\n\n    // Safe ERC20 helpers\n    function _safeTransfer(address _token, address to, uint256 amount) internal {\n        (bool ok, bytes memory data) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount));\n        require(ok && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER\");\n    }\n    function _safeTransferFrom(address _token, address from, address to, uint256 amount) internal {\n        (bool ok, bytes memory data) = _token.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, amount));\n        require(ok && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM\");\n    }\n\n    // ERC20 share logic\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(to != address(0) && to != address(this), \"bad to\");\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n    function transfer(address to, uint256 amount) external returns (bool) { _transfer(msg.sender, to, amount); return true; }\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount; // Allowance to 'to' \n            emit Approval(from, msg.sender, allowance[from][msg.sender]);\n        }\n        _transfer(from, to, amount); return true;\n    }\n    function approve(address spender, uint256 amount) external returns (bool) { allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; }\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) { \n        allowance[msg.sender][spender] += amount; \n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]); \n        return true; }\n\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) { \n        allowance[msg.sender][spender] -= amount; \n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]); \n        return true; }\n\n    // EIP-2612 permit See https://eips.ethereum.org/EIPS/eip-2612.\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes calldata signature) external returns (bool) {\n        require(owner != address(0), \"owner\");\n        require(deadline >= block.timestamp, \"expired\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _domainSeparatorV4(),\n                keccak256(abi.encode(\n                    PERMIT_TYPE_HASH, \n                    owner, \n                    spender, \n                    value, \n                    nonces[owner], \n                    deadline))\n            )\n        );\n        (bytes32 r, bytes32 s, uint8 v) = _splitSig(signature);\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory == owner, \"sig\");\n        allowance[owner][spender] = value;\n        nonces[owner] += 1;\n        emit Approval(owner, spender, value);\n        return true;\n    }\n    function _splitSig(bytes calldata sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"siglen\");\n        assembly {\n            r := calldataload(sig.offset)\n            s := calldataload(add(sig.offset, 32))\n            v := byte(0, calldataload(add(sig.offset, 64)))\n        }\n    }\n\n    // View helpers\n    function _totalAssets() internal view returns (uint256) { \n        return totalIdle + totalDebt; \n        }\n        \n    function totalAssets() external view returns (uint256) { return _totalAssets(); }\n\n    function _calculateLockedProfit() internal view returns (uint256) {\n        uint256 lockedFundsRatio = (block.timestamp - lastReport) * lockedProfitDegradation;\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\n            uint256 lp = lockedProfit;\n            return lp - ((lockedFundsRatio * lp) / DEGRADATION_COEFFICIENT);\n        } else {\n            return 0;\n        }\n    }\n    function _freeFunds() internal view returns (uint256) { return _totalAssets() - _calculateLockedProfit(); }\n\n    function _issueSharesForAmount(address to, uint256 amount) internal returns (uint256 shares) {\n        uint256 ts = totalSupply;\n        if (ts > 0) {\n            shares = (amount * ts) / _freeFunds();\n        } else {\n            shares = amount;\n        }\n        require(shares != 0, \"shares\");\n        totalSupply = ts + shares;\n        balanceOf[to] += shares;\n        emit Transfer(address(0), to, shares);\n    }\n\n    // NOTE: This is internal function so if we want to test it we want to make a wrapper\n    function _shareValue(uint256 shares) internal view returns (uint256) {\n        if (totalSupply == 0) return shares;\n        return (shares * _freeFunds()) / totalSupply;\n    }\n\n    function _shareValuePublic_(uint256 shares) external view returns (uint256) {\n        return _shareValue(shares);\n    }\n\n    // NOTE: This is internal function so if we want to test it we want to make a wrapper\n    function _sharesForAmount(uint256 amount) internal view returns (uint256) {\n        uint256 ff = _freeFunds();\n        if (ff > 0) return (amount * totalSupply) / ff; else return 0;\n    }\n\n    function _sharesForAmountPublic_(uint256 amount) external view returns (uint256) {\n        return _sharesForAmount(amount);\n    }\n\n    function maxAvailableShares() external view returns (uint256) {\n        uint256 shares = _sharesForAmount(totalIdle);\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) {\n            address s = withdrawalQueue[i];\n            if (s == address(0)) break;\n            shares += _sharesForAmount(strategies[s].totalDebt);\n        }\n        return shares;\n    }\n\n    // Core actions\n    function deposit(uint256 _amount, address recipient) external nonReentrant returns (uint256) {\n        if (recipient == address(0)) recipient = msg.sender;\n        require(!emergencyShutdown, \"shutdown\");\n        require(recipient != address(this), \"recipient\");\n\n        uint256 amount = _amount;\n        if (amount == MAX_UINT256) {\n            uint256 maxDep = depositLimit > _totalAssets() ? (depositLimit - _totalAssets()) : 0;\n            amount = MathLib.min(maxDep, IERC20(token).balanceOf(msg.sender));\n        } else {\n            if (depositLimit > 0) {\n                require(_totalAssets() + amount <= depositLimit, \"limit\");\n            }\n        }\n        require(amount > 0, \"amount\");\n\n        uint256 shares = _issueSharesForAmount(recipient, amount);\n        _safeTransferFrom(address(token), msg.sender, address(this), amount);\n        totalIdle += amount;\n        emit Deposit(recipient, shares, amount);\n        return shares;\n    }\n\n    function withdraw(uint256 maxShares, address recipient, uint256 maxLoss) external nonReentrant returns (uint256) {\n        if (recipient == address(0)) recipient = msg.sender;\n        require(maxLoss <= MAX_BPS, \"loss\");\n        uint256 shares = maxShares == MAX_UINT256 ? balanceOf[msg.sender] : maxShares;\n        require(shares > 0 && shares <= balanceOf[msg.sender], \"shares\");\n\n        uint256 value = _shareValue(shares);\n        uint256 vaultBalance = totalIdle;\n        uint256 totalLoss = 0;\n\n        if (value > vaultBalance) {\n            for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) {\n                address strat = withdrawalQueue[i];\n                if (strat == address(0)) break;\n                if (value <= vaultBalance) break;\n                uint256 amountNeeded = value - vaultBalance;\n                amountNeeded = MathLib.min(amountNeeded, strategies[strat].totalDebt);\n                if (amountNeeded == 0) continue;\n                uint256 pre = IERC20(token).balanceOf(address(this));\n                uint256 loss = IStrategy(strat).withdraw(amountNeeded);\n                uint256 withdrawn = IERC20(token).balanceOf(address(this)) - pre;\n                vaultBalance += withdrawn;\n                if (loss > 0) {\n                    value -= loss; totalLoss += loss; _reportLoss(strat, loss);\n                }\n                strategies[strat].totalDebt -= withdrawn; totalDebt -= withdrawn;\n                emit WithdrawFromStrategy(strat, strategies[strat].totalDebt, loss);\n            }\n            totalIdle = vaultBalance;\n            if (value > vaultBalance) {\n                value = vaultBalance;\n                shares = _sharesForAmount(value + totalLoss);\n            }\n            require(totalLoss <= (maxLoss * (value + totalLoss)) / MAX_BPS, \"excess loss\");\n        }\n\n        totalSupply -= shares;\n        balanceOf[msg.sender] -= shares;\n        emit Transfer(msg.sender, address(0), shares);\n\n        totalIdle -= value;\n        _safeTransfer(address(token), recipient, value);\n        emit Withdraw(recipient, shares, value);\n        return value;\n    }\n\n    // Price per shares\n    function pricePerShare() external view returns (uint256) { return _shareValue(10 ** decimals); }\n\n    // Queue organize helper\n    function _organizeWithdrawalQueue() internal {\n        uint256 offset;\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) {\n            address s = withdrawalQueue[i];\n            if (s == address(0)) { offset += 1; }\n            else if (offset > 0) { withdrawalQueue[i - offset] = s; withdrawalQueue[i] = address(0); }\n        }\n    }\n\n    // Strategy management\n    function addStrategy(address strategy, uint256 _debtRatio, uint256 minDebtPerHarvest, uint256 maxDebtPerHarvest, uint256 _performanceFee) external onlyGov {\n        require(withdrawalQueue[MAXIMUM_STRATEGIES - 1] == address(0), \"full\");\n        require(!emergencyShutdown, \"shutdown\");\n        require(strategy != address(0), \"addr\");\n        require(strategies[strategy].activation == 0, \"exists\");\n        require(IStrategy(strategy).vault() == address(this), \"vault\");\n        require(IStrategy(strategy).want() == address(token), \"want\");\n        require(debtRatio + _debtRatio <= MAX_BPS, \"ratio\");\n        require(minDebtPerHarvest <= maxDebtPerHarvest, \"range\");\n        require(_performanceFee <= MAX_BPS/2, \"pf\");\n\n        strategies[strategy] = StrategyParams({\n            performanceFee: _performanceFee,\n            activation: block.timestamp,\n            debtRatio: _debtRatio,\n            minDebtPerHarvest: minDebtPerHarvest,\n            maxDebtPerHarvest: maxDebtPerHarvest,\n            lastReport: block.timestamp,\n            totalDebt: 0,\n            totalGain: 0,\n            totalLoss: 0\n        });\n        emit StrategyAdded(strategy, _debtRatio, minDebtPerHarvest, maxDebtPerHarvest, _performanceFee);\n        debtRatio += _debtRatio;\n        withdrawalQueue[MAXIMUM_STRATEGIES - 1] = strategy;\n        _organizeWithdrawalQueue();\n    }\n\n    function updateStrategyDebtRatio(address strategy, uint256 _debtRatio) external onlyGovOrMgmt {\n        require(strategies[strategy].activation > 0, \"unknown\");\n        require(!IStrategy(strategy).emergencyExit(), \"emexit\");\n        debtRatio -= strategies[strategy].debtRatio;\n        strategies[strategy].debtRatio = _debtRatio;\n        debtRatio += _debtRatio;\n        require(debtRatio <= MAX_BPS, \"ratio\");\n        emit StrategyUpdateDebtRatio(strategy, _debtRatio);\n    }\n\n    function updateStrategyMinDebtPerHarvest(address strategy, uint256 m) external onlyGovOrMgmt {\n        require(strategies[strategy].activation > 0, \"unknown\");\n        require(strategies[strategy].maxDebtPerHarvest >= m, \"gt max\");\n        strategies[strategy].minDebtPerHarvest = m;\n        emit StrategyUpdateMinDebtPerHarvest(strategy, m);\n    }\n    function updateStrategyMaxDebtPerHarvest(address strategy, uint256 m) external onlyGovOrMgmt {\n        require(strategies[strategy].activation > 0, \"unknown\");\n        require(strategies[strategy].minDebtPerHarvest <= m, \"lt min\");\n        strategies[strategy].maxDebtPerHarvest = m;\n        emit StrategyUpdateMaxDebtPerHarvest(strategy, m);\n    }\n    function updateStrategyPerformanceFee(address strategy, uint256 pf) external onlyGov {\n        require(pf <= MAX_BPS/2, \"pf\");\n        require(strategies[strategy].activation > 0, \"unknown\");\n        strategies[strategy].performanceFee = pf;\n        emit StrategyUpdatePerformanceFee(strategy, pf);\n    }\n\n    function _revokeStrategy(address strategy) internal {\n        debtRatio -= strategies[strategy].debtRatio;\n        strategies[strategy].debtRatio = 0;\n        emit StrategyRevoked(strategy);\n    }\n\n    function migrateStrategy(address oldVersion, address newVersion) external onlyGov {\n        require(newVersion != address(0), \"addr\");\n        require(strategies[oldVersion].activation > 0, \"old\");\n        require(strategies[newVersion].activation == 0, \"new\");\n        StrategyParams memory s = strategies[oldVersion];\n        _revokeStrategy(oldVersion);\n        debtRatio += s.debtRatio;\n        strategies[oldVersion].totalDebt = 0;\n        strategies[newVersion] = StrategyParams({\n            performanceFee: s.performanceFee,\n            activation: s.lastReport,\n            debtRatio: s.debtRatio,\n            minDebtPerHarvest: s.minDebtPerHarvest,\n            maxDebtPerHarvest: s.maxDebtPerHarvest,\n            lastReport: s.lastReport,\n            totalDebt: s.totalDebt,\n            totalGain: 0,\n            totalLoss: 0\n        });\n        IStrategy(oldVersion).migrate(newVersion);\n        emit StrategyMigrated(oldVersion, newVersion);\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) { if (withdrawalQueue[i] == oldVersion) { withdrawalQueue[i] = newVersion; return; } }\n    }\n\n    function revokeStrategy(address strategy) external {\n        require(msg.sender == strategy || msg.sender == governance || msg.sender == guardian, \"auth\");\n        require(strategies[strategy].debtRatio != 0, \"zero\");\n        _revokeStrategy(strategy);\n    }\n\n    function addStrategyToQueue(address strategy) external onlyGovOrMgmt {\n        require(strategies[strategy].activation > 0, \"unknown\");\n        uint256 lastIdx;\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) { address s = withdrawalQueue[i]; if (s == address(0)) break; require(s != strategy, \"dup\"); lastIdx++; }\n        require(lastIdx < MAXIMUM_STRATEGIES, \"full\");\n        withdrawalQueue[MAXIMUM_STRATEGIES - 1] = strategy;\n        _organizeWithdrawalQueue();\n        emit StrategyAddedToQueue(strategy);\n    }\n\n    function removeStrategyFromQueue(address strategy) external onlyGovOrMgmt {\n        for (uint256 i=0;i<MAXIMUM_STRATEGIES;i++) { if (withdrawalQueue[i] == strategy) { withdrawalQueue[i] = address(0); _organizeWithdrawalQueue(); emit StrategyRemovedFromQueue(strategy); return; } }\n        revert(\"not in queue\");\n    }\n\n    // Debts and credit\n    function _debtOutstanding(address strategy) internal view returns (uint256) {\n        if (debtRatio == 0) return strategies[strategy].totalDebt;\n        uint256 strategyDebtLimit = (strategies[strategy].debtRatio * _totalAssets()) / MAX_BPS;\n        uint256 strategyTotalDebt = strategies[strategy].totalDebt;\n        if (emergencyShutdown) return strategyTotalDebt;\n        else if (strategyTotalDebt <= strategyDebtLimit) return 0; else return strategyTotalDebt - strategyDebtLimit;\n    }\n    function debtOutstanding(address strategy) external view returns (uint256) { if (strategy == address(0)) strategy = msg.sender; return _debtOutstanding(strategy); }\n\n    function _creditAvailable(address strategy) internal view returns (uint256) {\n        if (emergencyShutdown) return 0;\n        uint256 vTotalAssets = _totalAssets();\n        uint256 vDebtLimit = (debtRatio * vTotalAssets) / MAX_BPS;\n        uint256 vTotalDebt = totalDebt;\n        uint256 sDebtLimit = (strategies[strategy].debtRatio * vTotalAssets) / MAX_BPS;\n        uint256 sTotalDebt = strategies[strategy].totalDebt;\n        uint256 sMin = strategies[strategy].minDebtPerHarvest;\n        uint256 sMax = strategies[strategy].maxDebtPerHarvest;\n        if (sDebtLimit <= sTotalDebt || vDebtLimit <= vTotalDebt) return 0;\n        uint256 available = sDebtLimit - sTotalDebt;\n        available = MathLib.min(available, vDebtLimit - vTotalDebt);\n        available = MathLib.min(available, totalIdle);\n        if (available < sMin) return 0; else return MathLib.min(available, sMax);\n    }\n    function creditAvailable(address strategy) external view returns (uint256) { if (strategy == address(0)) strategy = msg.sender; return _creditAvailable(strategy); }\n\n    function _expectedReturn(address strategy) internal view returns (uint256) {\n        uint256 last = strategies[strategy].lastReport;\n        uint256 timeSince = block.timestamp - last;\n        uint256 totalHarvestTime = last - strategies[strategy].activation;\n        if (timeSince > 0 && totalHarvestTime > 0 && IStrategy(strategy).isActive()) {\n            return (strategies[strategy].totalGain * timeSince) / totalHarvestTime;\n        } else { return 0; }\n    }\n    function expectedReturn(address strategy) external view returns (uint256) { if (strategy == address(0)) strategy = msg.sender; return _expectedReturn(strategy); }\n\n    // Fees and reporting\n    function _assessFees(address strategy, uint256 gain) internal returns (uint256 total_fee) {\n        if (strategies[strategy].activation == block.timestamp) return 0;\n        uint256 duration = block.timestamp - strategies[strategy].lastReport; require(duration != 0, \"same block\");\n        if (gain == 0) return 0;\n        uint256 management_fee = ((strategies[strategy].totalDebt - IStrategy(strategy).delegatedAssets()) * duration * managementFee) / MAX_BPS / SECS_PER_YEAR;\n        uint256 strategist_fee = (gain * strategies[strategy].performanceFee) / MAX_BPS;\n        uint256 performance_fee_ = (gain * performanceFee) / MAX_BPS;\n        total_fee = management_fee + strategist_fee + performance_fee_;\n        if (total_fee > gain) total_fee = gain;\n        if (total_fee > 0) {\n            uint256 reward = _issueSharesForAmount(address(this), total_fee);\n            if (strategist_fee > 0) {\n                uint256 strategist_reward = (strategist_fee * reward) / total_fee;\n                _transfer(address(this), strategy, strategist_reward);\n            }\n            uint256 bal = balanceOf[address(this)];\n            if (bal > 0) _transfer(address(this), rewards, bal);\n        }\n        emit FeeReport(management_fee, performance_fee_, strategist_fee, duration);\n    }\n\n    function report(uint256 gain, uint256 loss, uint256 _debtPayment) external returns (uint256) {\n        require(strategies[msg.sender].activation > 0, \"unknown\");\n        require(IERC20(token).balanceOf(msg.sender) >= gain + _debtPayment, \"balance\");\n        if (loss > 0) { _reportLoss(msg.sender, loss); }\n        uint256 totalFees = _assessFees(msg.sender, gain);\n        strategies[msg.sender].totalGain += gain;\n        uint256 credit = _creditAvailable(msg.sender);\n        uint256 debt = _debtOutstanding(msg.sender);\n        uint256 debtPayment = MathLib.min(_debtPayment, debt);\n        if (debtPayment > 0) { strategies[msg.sender].totalDebt -= debtPayment; totalDebt -= debtPayment; debt -= debtPayment; }\n        if (credit > 0) { strategies[msg.sender].totalDebt += credit; totalDebt += credit; }\n        uint256 totalAvail = gain + debtPayment;\n        if (totalAvail < credit) { totalIdle -= (credit - totalAvail); _safeTransfer(address(token), msg.sender, credit - totalAvail); }\n        else if (totalAvail > credit) { totalIdle += (totalAvail - credit); _safeTransferFrom(address(token), msg.sender, address(this), totalAvail - credit); }\n        uint256 lockedProfitBeforeLoss = _calculateLockedProfit() + gain - totalFees;\n        if (lockedProfitBeforeLoss > loss) lockedProfit = lockedProfitBeforeLoss - loss; else lockedProfit = 0;\n        strategies[msg.sender].lastReport = block.timestamp; lastReport = block.timestamp;\n        emit StrategyReported(msg.sender, gain, loss, debtPayment, strategies[msg.sender].totalGain, strategies[msg.sender].totalLoss, strategies[msg.sender].totalDebt, credit, strategies[msg.sender].debtRatio);\n        if (strategies[msg.sender].debtRatio == 0 || emergencyShutdown) { return IStrategy(msg.sender).estimatedTotalAssets(); } else { return debt; }\n    }\n\n    function _reportLoss(address strategy, uint256 loss) internal {\n        uint256 totalDebt_ = strategies[strategy].totalDebt; require(totalDebt_ >= loss, \"loss\");\n        if (debtRatio != 0) {\n            uint256 ratio_change = 0;\n            if (totalDebt > 0) {\n                ratio_change = MathLib.min((loss * debtRatio) / totalDebt, strategies[strategy].debtRatio);\n            }\n            strategies[strategy].debtRatio -= ratio_change; debtRatio -= ratio_change;\n        }\n        strategies[strategy].totalLoss += loss;\n        strategies[strategy].totalDebt = totalDebt_ - loss; totalDebt -= loss;\n    }\n\n    function availableDepositLimit() external view returns (uint256) { return depositLimit > _totalAssets() ? depositLimit - _totalAssets() : 0; }\n\n    // The sweep() function lets the vault governance recover (sweep out) unexpected or leftover tokens that\n    //             shouldnt be in the vault  but protects the main vault asset.\n    function sweep(address _token, uint256 amount) external onlyGov {\n        uint256 value = amount;\n        if (value == MAX_UINT256) { value = IERC20(_token).balanceOf(address(this)); }\n        if (_token == address(token)) { value = IERC20(_token).balanceOf(address(this)) - totalIdle; }\n        emit Sweep(_token, value);\n        _safeTransfer(_token, governance, value);\n    }\n}\n\n\n","license":"MIT OR AGPL-3.0"}},"version":1},"id":9}